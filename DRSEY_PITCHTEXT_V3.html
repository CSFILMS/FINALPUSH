<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Unscramble + Images</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Background video */
    .bg-video {
      position: fixed;
      top: 50%;
      left: 60%;
      transform: translate(-50%, -50%) scaleX(0.8);
      width: calc(50vw - 2rem);
      height: calc(60vh - 2rem);
      object-fit: cover;
      object-position: center center;
      z-index: -1;
      pointer-events: none;
      display: none;
      filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      animation: videoFlicker 0.06s steps(1, end) infinite, hologramRoll 3s linear infinite, hologramGlitch 0.8s infinite;
      overflow: hidden;
    }
    
    /* Add hologram container for better effect control */
    .bg-video::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        0deg,
        transparent 0%,
        rgba(0, 255, 0, 0.1) 25%,
        rgba(0, 255, 0, 0.2) 50%,
        rgba(0, 255, 0, 0.1) 75%,
        transparent 100%
      );
      animation: verticalRoll 2s linear infinite;
      pointer-events: none;
      z-index: 1;
    }
    
    /* Video flicker animation */
    @keyframes videoFlicker {
      0% { filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2); }
      8% { filter: grayscale(1) brightness(0.58) contrast(1.25) sepia(1) hue-rotate(59deg) saturate(2.1); }
      15% { filter: grayscale(1) brightness(0.71) contrast(1.15) sepia(1) hue-rotate(61deg) saturate(1.9); }
      23% { filter: grayscale(1) brightness(0.55) contrast(1.28) sepia(1) hue-rotate(58deg) saturate(2.2); }
      31% { filter: grayscale(1) brightness(0.68) contrast(1.18) sepia(1) hue-rotate(62deg) saturate(1.8); }
      38% { filter: grayscale(1) brightness(0.61) contrast(1.22) sepia(1) hue-rotate(60deg) saturate(2.0); }
      46% { filter: grayscale(1) brightness(0.73) contrast(1.16) sepia(1) hue-rotate(61deg) saturate(1.9); }
      54% { filter: grayscale(1) brightness(0.57) contrast(1.26) sepia(1) hue-rotate(59deg) saturate(2.1); }
      62% { filter: grayscale(1) brightness(0.66) contrast(1.19) sepia(1) hue-rotate(60deg) saturate(2.0); }
      69% { filter: grayscale(1) brightness(0.59) contrast(1.24) sepia(1) hue-rotate(58deg) saturate(2.2); }
      77% { filter: grayscale(1) brightness(0.72) contrast(1.17) sepia(1) hue-rotate(62deg) saturate(1.8); }
      85% { filter: grayscale(1) brightness(0.62) contrast(1.21) sepia(1) hue-rotate(60deg) saturate(2.0); }
      92% { filter: grayscale(1) brightness(0.67) contrast(1.18) sepia(1) hue-rotate(61deg) saturate(1.9); }
      100% { filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2); }
    }
    
    /* Vertical roll displacement effect */
    @keyframes verticalRoll {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }
    
    /* Hologram rolling wave effect */
    @keyframes hologramRoll {
      0% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1);
        filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
      25% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1.02);
        filter: grayscale(1) brightness(0.68) contrast(1.15) sepia(1) hue-rotate(62deg) saturate(2.1);
      }
      50% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(0.98);
        filter: grayscale(1) brightness(0.6) contrast(1.25) sepia(1) hue-rotate(58deg) saturate(1.9);
      }
      75% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1.01);
        filter: grayscale(1) brightness(0.66) contrast(1.18) sepia(1) hue-rotate(61deg) saturate(2.05);
      }
      100% { 
        transform: translate(-50%, -50%) scaleX(0.8) scaleY(1);
        filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
    }
    
    /* Hologram glitch effect */
    @keyframes hologramGlitch {
      0%, 90%, 100% { 
        transform: translate(-50%, -50%) scaleX(0.8);
        opacity: 1;
      }
      92% { 
        transform: translate(-50.1%, -50%) scaleX(0.8);
        opacity: 0.95;
      }
      94% { 
        transform: translate(-49.9%, -50.05%) scaleX(0.8);
        opacity: 0.98;
      }
      96% { 
        transform: translate(-50.05%, -49.95%) scaleX(0.8);
        opacity: 0.96;
      }
      98% { 
        transform: translate(-49.95%, -50%) scaleX(0.8);
        opacity: 0.97;
      }
    }
    
    
    
    /* Video overlay (disabled for small centered video) */
    .bg-overlay {
      display: none;
    }
    /* Your actual content goes above (z-index > 0) */
    .content {
      position: relative;
      z-index: 1;
      color: #e8e8e8;
      font: 16px/1.5 system-ui, sans-serif;
      padding: 6vmin;
    }
    html,body { height:100%; margin:0; background:#000; }

    /* Font Definitions */
    @font-face {
      font-family: 'IBM3270';
      src: url('fonts/fonts/3270-Regular.ttf') format('truetype'),
           url('fonts/fonts/3270-Regular.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'PixelCarnageMono';
      src: url('fonts/fonts/PixelCarnageMono.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Crisp';
      src: url('fonts/fonts/Crisp.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggyCleanCE';
      src: url('fonts/fonts/ProggyCleanCE.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggySquare';
      src: url('fonts/fonts/ProggySquare.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    :root { 
      --fg:#D4D4D4; 
      --bg:#000; 
      --accent:#00FF00; 
      --soft:#66FF66;
      --font-family: 'Crisp', 'IBM3270', 'Courier New', monospace;
    }
    html, body { height:100%; }
    
    /* FORCE NO SCROLLING */
    html {
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    
    body {
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background:var(--bg); 
      color:var(--fg); 
      font-family:var(--font-family);
      padding:5vw; 
      perspective: 1000px; 
      padding-left: 25vw;
      max-width:80vw; 
      margin: 2vh auto; 
      line-height:1.6; 
      user-select:none;
      font-size: 1rem;
      min-height: 100vh;
      box-sizing: border-box;
    }
    
    /* CRT scanline effect */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
transparent 0px,
transparent 2px,
rgba(0, 255, 0, 0.03) 2px,
rgba(0, 255, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 99998;
    }
    
    /* Black scanlines on top */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
rgba(0, 0, 0, 0.26) 0px,
rgba(0, 0, 0, 0.26) 2px,
transparent 2px,
transparent 4px
      );
      pointer-events: none;
      z-index: 99999;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 0 !important;
        margin: 0 !important;
font-size: 0.8rem;
        padding-left: 0 !important;
        max-width: 100vw !important;
        width: 100vw !important;
        left: 0 !important;
        right: 0 !important;
      }
      #page {
        padding: 1vh 4vw; /* Increased horizontal padding for better mobile layout */
        height: 70vh; /* Increased height for mobile */
        min-height: 25em;
        width: 100% !important;
        max-width: 100% !important;
        margin: 0 !important;
        left: 0 !important;
        right: 0 !important;
      }
      #text-wrap {
        width: 100% !important; /* Force full width on mobile */
        max-width: 100% !important;
        margin-top: 0; /* Remove negative margin that was causing issues */
        height: calc(100% - 1rem); /* Adjust height calculation */
      }
            #unscramble {
        font-size: 0.8rem;
        line-height: 1.3;
        width: 100% !important; /* Force full width */
        max-width: 100% !important;
      }
      #nav {
font-size: 0.9rem;
        margin: 0.3vh 0 0.3vh;
      }
      #nav-msg {
font-size: 0.6rem;
      }
      #slide-counter {
        font-size: 0.5rem;
        margin: 0.3vh 0;
      }
      #prompt {
        font-size: 0.7rem;
      }
      
      /* Mobile video sizing - smaller on mobile */
      .bg-video {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 60vw;
        height: 40vh;
        object-fit: contain;
        object-position: center center;
      }
      
      /* Force full width on mobile regardless of image mode */
      #text-wrap.side-mode,
      #text-wrap.small-side-mode {
        width: 100% !important;
        max-width: 100% !important;
        position: relative !important;
        z-index: 2 !important;
      }
      
      #text-wrap.side-mode #unscramble,
      #text-wrap.small-side-mode #unscramble {
        width: 100% !important;
        max-width: 100% !important;
      }
    }
    
    @media screen and (min-resolution: 1dppx) {
            body {
        font-size: 1.0rem;
      }
    }
    #page {
      position:relative; 
      height: 60vh;
      min-height: 20em; 
      padding:2rem; 
      border-radius:10px;
      background-size:cover; 
      background-position:center; 
      background-repeat:no-repeat;
      overflow: visible; /* Allow text to be visible */
    }
    
 /* Simple image display */
     #page img {
       display: none;
       filter: grayscale(1) brightness(0.64) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
       /* Grayscale + green tint: black stays black, white becomes green */
       /* Ensure all image formats including GIFs display properly */
       image-rendering: auto;
     }
     
   /* Special rule: dim only photo7 - REMOVED (was too dark) */
      
      /* Special rule: dim only photo23 */
      #page img[id="img-23"] {
filter: grayscale(1) brightness(0.32) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
      
      /* Special rule: make page 10 images darker */
      #page img[id^="img-10"] {
filter: grayscale(1) brightness(0.35) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2);
      }
    
    #page img.show-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
      display: block;
    }
    
 #page img.show-below {
       display: block;
       margin-top: 1rem;
       max-height: 40%;
       max-width: 100%;
       object-fit: contain;
       position: relative;
       top: -12rem;
       z-index: -1;
     }
    
     #page img.show-side {
display: block;
position: absolute;
right: 0;
top: 0;
width: 50%;
height: 100%;
object-fit: cover;
z-index: 1;
      }
      
     #page img.show-small-side {
 display: block;
 position: absolute;
 right: 0;
 top: 0;
 width: 25%;
 height: 60%;
 object-fit: cover;
 z-index: 1;
       }
    
    /* Text container width is now controlled by JavaScript */
    
    /* Hide the default cursor */
    body {
      cursor: none;
    }
    
    /* Custom cursor element */
    #custom-cursor {
      position: fixed;
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      mix-blend-mode: difference;
      display: none;
    }
    
    /* Video loading status */
    #video-loading {
      position: fixed;
      top: calc(100vh - 8rem);
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10001;
      text-align: center;
      pointer-events: none;
    }
    
    .loading-text {
      font-family: var(--font-family);
      font-size: 1.2rem;
      color: var(--soft);
      text-shadow: 0 0 2px var(--soft), 0 0 12px var(--soft);
      margin-bottom: 1.5rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }
    
    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(102, 255, 102, 0.2);
      border: 1px solid var(--soft);
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .loading-progress {
      height: 100%;
      background: var(--soft);
      box-shadow: 0 0 4px var(--soft);
      width: 0%;
      transition: width 0.3s ease;
      animation: loadingPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes loadingPulse {
      0%, 100% { 
        opacity: 0.6;
        box-shadow: 0 0 4px var(--soft);
      }
      50% { 
        opacity: 1;
        box-shadow: 0 0 8px var(--soft), 0 0 16px var(--soft);
      }
    }
    
    /* Mobile loading status */
    @media (max-width: 768px) {
      .loading-text {
        font-size: 1rem;
      }
      .loading-bar {
        width: 250px;
        height: 3px;
      }
    }
    
 #text-wrap { 
       min-width:0; 
       margin-top: -1.4rem; 
       width: 100%;
       height: calc(100% - 2rem); /* Ensure text doesn't overlap with navbar */
       box-sizing: border-box;
       overflow: hidden;
     }
     
     /* Mobile-specific text-wrap overrides */
     @media (max-width: 768px) {
       #text-wrap {
         margin-top: 0; /* Remove negative margin on mobile */
         height: calc(100% - 1rem); /* Better height calculation for mobile */
       }
     }
                    #unscramble { 
      white-space: pre-wrap; 
      font-size: 0.99rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      height: 100%;
      overflow: hidden;
      width: 100%;
      box-sizing: border-box;
      max-width: 100%;
      /* Preserve original formatting - no text wrapping modifications */
      text-indent: 0;
      word-break: normal;
      hyphens: none;
    }
     
     /* Handle indented line wrapping - preserve indentation for continuation lines */
     #unscramble .indented-line {
       display: block;
       text-indent: 2em; /* Standard indentation */
     }
     
     #unscramble .continuation {
       display: block;
       text-indent: 2em; /* Same indentation as parent */
     }
    #prompt { 
      margin-top:1rem; 
      visibility:hidden; 
      white-space:pre-wrap; 
      line-height:1.3; 
      font-size: 0.9rem;
    }

    #nav { 
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 1vh 0 0.5vh; 
      font-size: 0.9rem;
      min-height: 5vh;
      position: relative;
      gap: 4vw;
    }
    #nav span { cursor:pointer; user-select:none; padding:0 1em; }
          #nav-msg { 
      flex-grow:1; 
      text-align:center; 
      font-size:0.6rem;
      min-height: 1.5rem;
      visibility: hidden;
    }
    
    #slide-counter {
      position: relative;
      top: 0.5vh;
      left: 0;
      transform: none;
      font-size: 0.6rem;
      opacity: 1;
      color: var(--accent);
      text-shadow: 0 0 2px var(--accent), 0 0 12px var(--accent);
      font-family: var(--font-family);
      pointer-events: none;
      z-index: 1000;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      text-align: center;
      margin: 0.5vh 0;
    }
    
   /* Side mode: text on left, image on right */
      #text-wrap.side-mode {
width: 50% !important;
max-width: 50% !important;
position: relative !important;
z-index: 2 !important;
      }
      
     /* Small side mode: text on left, smaller image on right */
       #text-wrap.small-side-mode {
 width: 75% !important;
 max-width: 75% !important;
 position: relative !important;
 z-index: 2 !important;
       }
    
  #text-wrap.side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
    }
    
    #text-wrap.small-side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      font-size: 1.0rem !important;
      line-height: 1.3 !important;
    }
    
    /* Prevent any formatting interference with timeline content */
    #unscramble[data-timeline="true"] {
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      word-break: normal !important;
      line-height: 1.5 !important;
    }
    
    /* Collateral Murder video slide animation */
    #unscramble.collateral-murder-slide {
      animation: moveUpwards 3s ease-out forwards;
      position: relative;
      z-index: 10;
    }
    
    @keyframes moveUpwards {
      0% {
        transform: translateY(0);
      }
      100% {
        transform: translateY(-50vh);
      }
    }
    
    /* Persistent text that stays on screen */
    #persistent-text {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1000;
      pointer-events: none;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 2rem;
    }
    
    #persistent-text .text-content {
      color: var(--accent);
      font-family: var(--font-family);
      font-size: 2rem;
      text-align: center;
      font-weight: bold;
      text-shadow: 0 0 10px var(--accent);
    }
    
    /* Video loading text - simple like slide text */
    #video-loading {
      position: fixed;
      top: 50%;
      left: 60%;
      transform: translate(-50%, -50%);
      z-index: 10;
      font-family: var(--font-family);
      color: var(--accent);
      font-size: 1.2rem;
      text-align: center;
    }
    
    .loading-text {
      margin-bottom: 1rem;
    }
    
    .loading-dots {
      display: inline-block;
    }
    
    .loading-dots span {
      animation: loadingDots 1.5s infinite;
      animation-fill-mode: both;
    }
    
    .loading-dots span:nth-child(1) { animation-delay: 0s; }
    .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
    .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes loadingDots {
      0%, 20% { opacity: 0; }
      50% { opacity: 1; }
      80%, 100% { opacity: 0; }
    }
    
    .loading-bar {
      display: none;
    }
    
    .loading-progress {
      display: none;
    }
     

  </style>
</head>
<body>
  <!-- Removed unused video elements to optimize file size -->

  <video
    id="bg-video3"
    class="bg-video"
    autoplay
    muted
    playsinline
    preload="metadata"
    aria-hidden="true"
    tabindex="-1"
    disablepictureinpicture
    controlslist="nodownload noplaybackrate noptimizequality nodatachannel"
    volume="0"
    defaultMuted
    style="display: none;"
  >
    <source src="OBIWAN_REAL.mp4" type="video/mp4" />
  </video>
  
  <audio
    id="obiwan-audio"
    preload="metadata"
    style="display: none;"
  >
    <source src="OBIWAN_REAL.mp4" type="audio/mp4" />
  </audio>

  <div class="bg-overlay" id="bg-overlay" style="display: none;"></div>

  <div id="page">
    <div id="text-wrap">
      <div id="unscramble"></div>
      <div id="prompt"></div>
    </div>
    
    <!-- Images will be added here dynamically -->
  </div>

  <div id="nav">
    <span id="nav-prev">&lt;</span>
    <span id="nav-msg"></span>
    <span id="nav-next">&gt;</span>
  </div>

  <div id="slide-counter">SLIDE 1 / 1</div>

  <!-- Video loading status -->
  <div id="video-loading" style="display: none;">
    <div class="loading-text">LOADING VIDEO<span class="loading-dots"><span>.</span><span>.</span><span>.</span></span></div>
    <div class="loading-bar">
      <div class="loading-progress"></div>
    </div>
  </div>
  
  <!-- Custom cursor -->
  <div id="custom-cursor"></div>

  <script>
    /* ================== CONTENT ================== */
    const fullTextRaw = `
RECIPIENT: DORSEY.6BDM

EYES ONLY / NO FWD / 
NO DSTRO

SOURCE: CSF
FILE ID: 369-108-11






THE SIX BILLION DOLLAR
MAN


PRESS [F] FOR FULL SCREEN





A FILM BY EUGENE JARECKI


6BDM: JULIAN ASSANGE AND THE PRICE OF TRUTH





2006: 
  > JULIAN ASSANGE [JA] IS ALIGNED WITH CRYPTO AND CYPHERPUNK AGITATORS IN THE FIGHT FOR DECENTRALIZATION, PRIVACY, AND FREEDOM OF INFORMATION.
  > JA BUILDS WIKILEAKS [WL], A SECURE PUBLISHING PLATFORM TO HELP WHISTLEBLOWERS BYPASS LEGACY MEDIA.
2010: 
  > WL RELEASES A CLASSIFIED INTERNAL U.S. MILITARY VIDEO, EXPOSING U.S. WAR CRIMES COMMITTED IN IRAQ. 
2011-2012: 
  > WL PUBLISHES 6 OF THE 10 LARGEST RELEASES OF SENSITIVE MATERIAL IN U.S. HISTORY. UK AUTHORITIES CARRY OUT INTERPOL ARREST WARRANT. JA TAKES REFUGE IN ECUADORIAN EMBASSY, LONDON.
2017: 
  > JA FORCIBLY REMOVED FROM EMBASSY.
2017-2024: 
  > JA IS INMATE #A9379AY AT HMP BELMARSH, MAX. SEC. 
2024: 
  > US. DROPS 17/18 COUNTS AGAINST JA, DISMISSES CASE. 
  > JA RETURNED TO AUSTRALIA. 





THE FAILED WAR ON JA IS A STORY THE WORLD NEEDS TO HEAR. BUT THIS WON’T HAPPEN WITHOUT A RADICAL RELEASE PLAN. 


IN 2025, 6BDM WON THE CANNES FILM FESTIVAL AND FIRST-EVER GOLDEN GLOBE FOR DOCUMENTARY. BUT NO STREAMER OR BROADCASTER WILL TOUCH IT. 





IN THE MODE OF WL, 6BDM’S RELEASE WILL BYPASS TRADITIONAL MEDIA.

A LEADING INFLUENCER WILL INTERVIEW JA AND GUIDE TRAFFIC TO THE FILM BEHIND A PAYWALL. 

TO PROMOTE THIS TO A GLOBAL AUDIENCE, WE SEEK TO RAISE A P&A ARSENAL FROM WITHIN THE CRYPTO/CYPHER WORLD



`;

    /* ================== AUDIO SYSTEM ================== */
    let audioContext = null;
    let audioEnabled = false;
    let debugMode = true;
    let currentSoundVariation = 0; // 0-4 for 5 different variations
    let currentAudio = null; // Track currently playing audio
    let audioVolume = 0.7; // Default volume level
    
    // Function to stop any currently playing audio
    function stopCurrentAudio() {
      if (currentAudio) {
        console.log('🛑 Stopping current audio...');
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio.src = ''; // Clear the source
        currentAudio.load(); // Reset the audio element
        currentAudio = null;
      }
      
      // Stop any visualizers (disabled)
      stop3DVisualizer();
      
      // Also stop any other audio elements that might be playing
      const allAudioElements = document.querySelectorAll('audio');
      allAudioElements.forEach(audio => {
        if (!audio.paused) {
          audio.pause();
          audio.currentTime = 0;
        }
      });
    }
    
    
    
    
    
    // Visualizer variables (disabled)
    let visualizerScene = null;
    let visualizerCamera = null;
    let visualizerRenderer = null;
    let visualizerMesh = null;
    let visualizerUniforms = null;
    let visualizerAnalyser = null;
    let visualizerDataArray = null;
    let visualizerRunning = false;
    let visualizerComposer = null;

    // Visualizer functions (disabled)
    function init3DVisualizer() {
      // Disabled
    }

    function start3DVisualizer(audioElement) {
      // Disabled
    }

    function stop3DVisualizer() {
      // Disabled
    }

    function animate3DVisualizer() {
      // Disabled
    }

    // Mouse tracking for camera movement
    let mouseX = 0;
    let mouseY = 0;
    document.addEventListener('mousemove', function (e) {
      const windowHalfX = window.innerWidth / 2;
      const windowHalfY = window.innerHeight / 2;
      mouseX = (e.clientX - windowHalfX) / 100;
      mouseY = (e.clientY - windowHalfY) / 100;
      window.mouseX = mouseX;
      window.mouseY = mouseY;
    });

    // Test audio function
    function testAudio() {
      console.log('🧪 Testing audio playback...');
      const testAudio = new Audio('AUDIO/audio15.mp3');
      testAudio.volume = 0.7;
      
      testAudio.addEventListener('play', () => {
        console.log('✅ Test audio started playing!');
      });
      
      testAudio.addEventListener('error', (e) => {
        console.error('❌ Test audio error:', e);
      });
      
      testAudio.play().then(() => {
        console.log('✅ Test audio playing successfully');
      }).catch(err => {
        console.log('❌ Test audio play failed:', err.message);
        console.log('🔧 Error details:', err);
      });
    }

    // Removed unused video functions to optimize file size

    // Unlock audio context on user interaction
    function unlockAudioContext() {
      if (!audioContextUnlocked) {
        console.log('🔓 Unlocking audio context...');
        
        // Create a silent audio to unlock the context
        const audio = document.getElementById('obiwan-audio');
        if (audio) {
          audio.muted = true;
          audio.play().then(() => {
            audio.pause();
            audio.muted = false;
            audio.currentTime = 0;
            audioContextUnlocked = true;
            console.log('✅ Audio context unlocked');
          }).catch(err => {
            console.log('❌ Audio unlock failed:', err.message);
          });
        }
      }
    }

    // Video loading status functions
    function showVideoLoading() {
      console.log('📺 Showing video loading status...');
      const loadingEl = document.getElementById('video-loading');
      const progressEl = document.querySelector('.loading-progress');
      
      if (loadingEl && progressEl) {
        loadingEl.style.display = 'block';
        progressEl.style.width = '0%';
        
        // Animate progress bar
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += Math.random() * 15; // Random progress increments
          if (progress > 90) progress = 90; // Cap at 90% until video is ready
          progressEl.style.width = progress + '%';
        }, 200);
        
        // Store interval ID for cleanup
        loadingEl.dataset.progressInterval = progressInterval;
      }
    }
    
    function hideVideoLoading() {
      console.log('✅ Hiding video loading status...');
      const loadingEl = document.getElementById('video-loading');
      const progressEl = document.querySelector('.loading-progress');
      
      if (loadingEl) {
        // Complete the progress bar
        if (progressEl) {
          progressEl.style.width = '100%';
        }
        
        // Clear progress animation
        const intervalId = loadingEl.dataset.progressInterval;
        if (intervalId) {
          clearInterval(intervalId);
          delete loadingEl.dataset.progressInterval;
        }
        
        // Force hide immediately and with fallback
        loadingEl.style.display = 'none';
        loadingEl.style.visibility = 'hidden';
        loadingEl.style.opacity = '0';
        
        // Additional fallback for mobile
        setTimeout(() => {
          if (loadingEl) {
            loadingEl.style.display = 'none';
            loadingEl.style.visibility = 'hidden';
            loadingEl.style.opacity = '0';
          }
        }, 100);
      }
    }

    // Video3 (JA_OBIWAN) functions - with audio that stops when slide changes
    function showVideo3Background() {
      console.log('🎬 Showing JA_OBIWAN hologram video with audio...');
      const video = document.getElementById('bg-video3');
      const audio = document.getElementById('obiwan-audio');
      
      if (video) {
        // Show loading status first
        showVideoLoading();
        
        // Keep video hidden initially
        video.style.display = 'none';
        video.muted = true;   // Keep video muted
        video.loop = true;    // Video loops visually
        video.currentTime = 0;
        
        // Set up video event listeners
        const onCanPlay = () => {
          console.log('✅ Video3 ready to play');
          // Hide loading first, then show video after a brief delay
          hideVideoLoading();
          setTimeout(() => {
            video.style.display = 'block';
            console.log('✅ Video3 now visible');
          }, 200); // 200ms delay to ensure loading bar disappears first
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        const onError = (e) => {
          console.log('❌ Video3 failed to load:', e);
          hideVideoLoading();
          video.removeEventListener('canplay', onCanPlay);
          video.removeEventListener('error', onError);
        };
        
        video.addEventListener('canplay', onCanPlay);
        video.addEventListener('error', onError);
        
        video.play().catch(err => {
          console.log('Video3 play failed:', err.message);
          hideVideoLoading();
        });
      }
      
      if (audio) {
        audio.volume = 0.7;   // Set audio volume
        audio.muted = false;  // Ensure not muted
        audio.currentTime = 0;
        
        // Try to play with better error handling
        console.log('🔊 Attempting to play audio...');
        audio.play().then(() => {
          console.log('✅ Audio playing successfully');
        }).catch(err => {
          console.log('❌ Audio play failed:', err.message);
          console.log('🔧 This might require user interaction first');
        });
      }
    }

    function hideVideo3Background() {
      console.log('🛑 Hiding JA_OBIWAN video and stopping audio...');
      const video = document.getElementById('bg-video3');
      const audio = document.getElementById('obiwan-audio');
      
      if (video) {
        video.pause();
        video.style.display = 'none';
      }
      
      if (audio) {
        audio.pause();
        audio.currentTime = 0; // Reset to beginning
      }
    }
    
    // Enhanced audio context initialization with mobile support
    function initAudioContext() {
      if (debugMode) console.log('🔊 Initializing audio context...');
      
      if (!audioContext) {
        try {
          // Use the most compatible audio context for mobile
          const AudioContextClass = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
          audioContext = new AudioContextClass();
          console.log('✅ Audio context created successfully:', audioContext.state);
          
          // Resume audio context if suspended (required by mobile browsers)
          if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('✅ Audio context resumed from suspended state');
              audioEnabled = true;
            }).catch(err => {
              console.error('❌ Failed to resume audio context:', err);
              // Try to enable audio anyway for mobile
              audioEnabled = true;
            });
          } else {
            audioEnabled = true;
          }
          
          // Mobile-specific audio context handling
          if (audioContext.state === 'running') {
            audioEnabled = true;
          }
          
        } catch (e) {
          console.error('❌ Audio context creation failed:', e);
          // Don't disable audio completely on mobile - try to continue
          audioEnabled = true;
          showAudioError('Audio context failed, but continuing...');
        }
      }
      return audioContext !== null;
    }
    
    // Show audio error in the UI
    function showAudioError(message) {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = `AUDIO ERROR: ${message}`;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#FF6666';
        
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 3000);
      }
    }
    
    // Enhanced beep function with multiple fallback methods
    function playBeep(frequency = 800, duration = 0.08, volume = 0.5) {
      if (!audioEnabled) {
        if (debugMode) console.log('🔇 Audio disabled, skipping beep');
        return;
      }
      
      if (!audioContext && !initAudioContext()) {
        if (debugMode) console.error('❌ No audio context available');
        return;
      }
      
      try {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Use sine wave for better compatibility
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        
        // Envelope for smooth attack/decay
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
        
        if (debugMode) console.log('✅ Beep scheduled successfully');
        
      } catch (e) {
        console.error('❌ Beep playback failed:', e);
        showAudioError('Playback failed');
      }
    }
    
    // Test beep with camera shutter burst
    function testBeep() {
      console.log('🧪 Testing camera shutter audio...');
      
      // Show visual feedback
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        navMsg.textContent = 'TESTING SHUTTER BEEPS...';
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#FFFF00';
      }
      
      // Initialize audio if needed
      if (!initAudioContext()) {
        console.error('❌ Test failed: Could not initialize audio');
        return;
      }
      
      // Play rapid shutter-like test sequence
      const frequency = 1200;
      const volume = 0.4;
      const beepDuration = 0.025;
      const rapidBeeps = 8; // More beeps for testing
      
      for (let i = 0; i < rapidBeeps; i++) {
        setTimeout(() => {
          playBeep(frequency, beepDuration, volume);
        }, i * 12); // Very rapid - 12ms between beeps
      }
      
      // Restore UI after test
      setTimeout(() => {
        if (navMsg) {
          navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
          navMsg.style.fontSize = '0.9rem';
          navMsg.style.color = '';
        }
      }, 1000);
    }
    
    // 5 Different shutter sound variations
    const soundVariations = [
      {
        name: "Classic Shutter",
        frequency: 1200,
        beepsPerChunk: 4,
        timeBetweenBeeps: 10,
        beepDuration: 0.025,
        volume: 0.15
      },
      {
        name: "Deep Mechanical",
        frequency: 800,
        beepsPerChunk: 3,
        timeBetweenBeeps: 15,
        beepDuration: 0.035,
        volume: 0.18
      },
      {
        name: "High Frequency Burst",
        frequency: 1600,
        beepsPerChunk: 6,
        timeBetweenBeeps: 8,
        beepDuration: 0.020,
        volume: 0.12
      },
      {
        name: "Stutter Pattern",
        frequency: 1000,
        beepsPerChunk: 5,
        timeBetweenBeeps: [5, 5, 20, 5, 5], // Variable timing for stutter effect
        beepDuration: 0.030,
        volume: 0.16
      },
      {
        name: "Dual Tone",
        frequency: [1400, 1100], // Two alternating frequencies
        beepsPerChunk: 4,
        timeBetweenBeeps: 12,
        beepDuration: 0.025,
        volume: 0.14
      }
    ];
    
    // Rapid camera shutter-like beeps with variations
    function playDecodingBeeps(chunkIndex, totalChunks) {
      if (!audioEnabled) return;
      
      const variation = soundVariations[currentSoundVariation];
      
      for (let i = 0; i < variation.beepsPerChunk; i++) {
        setTimeout(() => {
          let freq = variation.frequency;
          let vol = variation.volume;
          
          // Handle special variations
          if (currentSoundVariation === 3) { // Stutter Pattern
            // Use variable timing array
            const delay = variation.timeBetweenBeeps.slice(0, i).reduce((a, b) => a + b, 0);
          } else if (currentSoundVariation === 4) { // Dual Tone
            // Alternate between two frequencies
            freq = variation.frequency[i % 2];
          }
          
          playBeep(freq, variation.beepDuration, vol);
        }, getBeepDelay(variation, i));
      }
    }
    
    // Calculate delay for each beep based on variation
    function getBeepDelay(variation, beepIndex) {
      if (currentSoundVariation === 3 && Array.isArray(variation.timeBetweenBeeps)) {
        // Stutter pattern with variable timing
        return variation.timeBetweenBeeps.slice(0, beepIndex).reduce((a, b) => a + b, 0);
      } else {
        // Regular timing
        const timing = Array.isArray(variation.timeBetweenBeeps) ? 
                      variation.timeBetweenBeeps[0] : variation.timeBetweenBeeps;
        return beepIndex * timing;
      }
    }
    
    // Cycle to next sound variation
    function nextSoundVariation() {
      currentSoundVariation = (currentSoundVariation + 1) % soundVariations.length;
      showSoundVariation();
      testCurrentVariation();
    }
    
    // Cycle to previous sound variation
    function prevSoundVariation() {
      currentSoundVariation = (currentSoundVariation - 1 + soundVariations.length) % soundVariations.length;
      showSoundVariation();
      testCurrentVariation();
    }
    
    // Show current sound variation in UI
    function showSoundVariation() {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const variation = soundVariations[currentSoundVariation];
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = `SOUND: ${variation.name.toUpperCase()}`;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#00FFFF';
        
        console.log(`🎵 Switched to: ${variation.name}`);
        
        // Restore UI after showing variation
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 1500);
      }
    }
    
    // Test current sound variation
    function testCurrentVariation() {
      if (!audioEnabled) return;
      
      const variation = soundVariations[currentSoundVariation];
      
      // Play a sample of the current variation
      setTimeout(() => {
        for (let i = 0; i < variation.beepsPerChunk; i++) {
          setTimeout(() => {
            let freq = variation.frequency;
            
            // Handle special variations for testing
            if (currentSoundVariation === 4) { // Dual Tone
              freq = variation.frequency[i % 2];
            }
            
            playBeep(freq, variation.beepDuration, variation.volume);
          }, getBeepDelay(variation, i));
        }
      }, 300);
    }

    // Toggle audio with enhanced feedback
    function toggleAudio() {
      audioEnabled = !audioEnabled;
      console.log(`🔊 Audio ${audioEnabled ? 'ENABLED' : 'DISABLED'}`);
      
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = audioEnabled ? 'SOUND ON' : 'SOUND OFF';
        navMsg.style.visibility = 'visible';
        navMsg.style.color = audioEnabled ? '#00FF00' : '#FF6666';
        
        // Play confirmation beep if enabling
        if (audioEnabled) {
          setTimeout(() => {
            testBeep();
          }, 200);
        }
        
        // Restore UI
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 2000);
      }
    }

    // Enhanced audio function for page 8
    function playAudioForPage8() {
      console.log('🎵 Attempting to play audio for page 8...');
      
      if (!audioEnabled) {
        console.log('🔇 Audio disabled, skipping');
        return;
      }
      
      // Stop any current audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      // Create new audio with better error handling
      const audio = new Audio();
      audio.src = 'AUDIO/audio7.mp3';
      audio.volume = audioVolume;
      audio.preload = 'auto';
      
      console.log('🎵 Audio source:', audio.src);
      console.log('🎵 Audio volume:', audioVolume);
      console.log('🎵 Audio enabled:', audioEnabled);
      
      // Multiple event listeners for better compatibility
      audio.addEventListener('loadstart', () => {
        console.log('🔄 Audio loading started');
      });
      
      audio.addEventListener('loadeddata', () => {
        console.log('📊 Audio data loaded');
      });
      
      audio.addEventListener('canplay', () => {
        console.log('▶️ Audio can play');
        currentAudio = audio;
        audio.play().then(() => {
          console.log('✅ Audio playing for page 8');
        }).catch(err => {
          console.error('❌ Audio play failed:', err);
          console.error('❌ Error details:', err.message);
          showAudioError('Audio play failed: ' + err.message);
        });
      });
      
      audio.addEventListener('error', (e) => {
        console.error('❌ Audio load failed:', e);
        console.error('❌ Audio src was:', audio.src);
        console.error('❌ Error code:', audio.error ? audio.error.code : 'unknown');
        showAudioError('Audio file not found or corrupted');
      });
      
      // Force load
      audio.load();
    }

    // Enhanced audio function for page 12
    function playAudioForPage12() {
      console.log('🎵 Attempting to play audio for page 12...');
      
      if (!audioEnabled) {
        console.log('🔇 Audio disabled, skipping');
        return;
      }
      
      // Stop any current audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }
      
      // Create new audio with better error handling
      const audio = new Audio();
      audio.src = 'AUDIO/audio9.mp3';
      audio.volume = audioVolume;
      audio.preload = 'auto';
      
      console.log('🎵 Audio source:', audio.src);
      console.log('🎵 Audio volume:', audioVolume);
      console.log('🎵 Audio enabled:', audioEnabled);
      
      // Multiple event listeners for better compatibility
      audio.addEventListener('loadstart', () => {
        console.log('🔄 Audio loading started');
      });
      
      audio.addEventListener('loadeddata', () => {
        console.log('📊 Audio data loaded');
      });
      
      audio.addEventListener('canplay', () => {
        console.log('▶️ Audio can play');
        currentAudio = audio;
        audio.play().then(() => {
          console.log('✅ Audio playing for page 12');
        }).catch(err => {
          console.error('❌ Audio play failed:', err);
          console.error('❌ Error details:', err.message);
          showAudioError('Audio play failed: ' + err.message);
        });
      });
      
      audio.addEventListener('error', (e) => {
        console.error('❌ Audio load failed:', e);
        console.error('❌ Audio src was:', audio.src);
        console.error('❌ Error code:', audio.error ? audio.error.code : 'unknown');
        showAudioError('Audio file not found or corrupted');
      });
      
      // Force load
      audio.load();
    }

    /* ================== PREP ================== */
    const fullText = fullTextRaw.toUpperCase();
    const pages = fullText.split(/\n{4,}/);
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,\'"?!-—:;\n';

 // Image modes
     const IMG_OFF = 0;
     const IMG_BG = 1;
     const IMG_BELOW = 2;
     const IMG_SIDE = 3;
     const IMG_SMALL_SIDE = 4;
    
    // Helper functions for cycling through image modes
    function getNextImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex + 1) % modes.length];
    }
    
    function getPreviousImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex - 1 + modes.length) % modes.length];
    }
    
    function markUserSetMode(pageIndex) {
      const pageNumber = pageIndex + 1;
      const imgEl = document.getElementById(`img-${pageNumber}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
      // Save to localStorage for persistence across refreshes
      savePageModeToStorage(pageIndex, pageModes[pageIndex]);
    }
    
    function savePageModeToStorage(pageIndex, mode) {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
storedModes[pageIndex] = mode;
localStorage.setItem('pitchDeckImageModes', JSON.stringify(storedModes));
      } catch (e) {
console.warn('Could not save image mode to localStorage:', e);
      }
    }
    
    function loadPageModesFromStorage() {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
Object.keys(storedModes).forEach(pageIndex => {
  const index = parseInt(pageIndex);
  if (index >= 0 && index < pageModes.length) {
    pageModes[index] = storedModes[pageIndex];
    // Mark as user-set so auto-detection doesn't override
    setTimeout(() => {
      const imgEl = document.getElementById(`img-${index + 1}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
    }, 100);
  }
});
      } catch (e) {
console.warn('Could not load image modes from localStorage:', e);
      }
    }
    
 const pageModes = new Array(pages.length).fill(IMG_BG); // Default to background image mode for all pages
    
    
    // Load saved image modes from localStorage
    loadPageModesFromStorage();
    
    // Disable keyword scanning completely for faster loading
    console.log('Image keyword scanning disabled - no images available');
    
    // Skip all image scanning since no images are available
    // This prevents the slow startup delay
    
    // Debug function - call from browser console: testImage('ignorant')
    window.testImage = function(keyword) {
      console.log(`Testing image for keyword: ${keyword}`);
      const img = document.createElement('img');
      img.src = `photos/photo_${keyword}.webp`;
      img.onload = () => {
        console.log(`✅ Image loaded: photos/photo_${keyword}.webp`);
        availableKeywords.add(keyword);
        console.log('Available keywords:', Array.from(availableKeywords));
      };
      img.onerror = () => {
        console.log(`❌ Image failed: photos/photo_${keyword}.webp`);
      };
    };
    
    // Debug function - test audio 8
    window.testAudio8 = function() {
      console.log('🎵 Testing audio 8...');
      playAudioForPage8();
    };
    
    // Debug function - test audio 12
    window.testAudio12 = function() {
      console.log('🎵 Testing audio 12...');
      playAudioForPage12();
    };
    
    // Simple test function for audio 8
    window.testAudio7Simple = function() {
      console.log('🎵 Testing audio7.mp3...');
      const audio = new Audio('AUDIO/audio7.mp3');
      audio.volume = 0.7;
      audio.play().then(() => {
        console.log('✅ Audio7 playing successfully');
      }).catch(err => {
        console.log('❌ Audio7 failed:', err.message);
      });
    };
    
    // Simple test function for audio 15
    window.testAudio15Simple = function() {
      console.log('🎵 Testing audio15.mp3...');
      const audio = new Audio('AUDIO/audio15.mp3');
      audio.volume = 0.7;
      audio.play().then(() => {
        console.log('✅ Audio15 playing successfully');
      }).catch(err => {
        console.log('❌ Audio15 failed:', err.message);
      });
    };
    
    // Test visualizer function
    window.testVisualizer = function() {
      console.log('🎨 Testing visualizer...');
      const canvas = document.getElementById('audio-visualizer');
      if (canvas) {
        canvas.style.display = 'block';
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'red';
        ctx.fillRect(100, 100, 200, 200);
        console.log('✅ Visualizer test - red square should appear');
      } else {
        console.error('❌ Canvas not found');
      }
    };
    

    // DOM
    const pageEl = document.getElementById('page');
    const textWrap = document.getElementById('text-wrap');
    const el = document.getElementById('unscramble');
    const promptElem = document.getElementById('prompt');
    const navMsg = document.getElementById('nav-msg');
    const slideCounterEl = document.getElementById('slide-counter');

    let currentPage = 0;
    let isAnimating = false;
    let currentInterval = null;
    let availableKeywords = new Set(); // Store available photo keywords
    let audioTimeout = null; // Track audio timeout
    let lineRevealTimeouts = []; // Track line reveal timeouts
    let isInLineRevealMode = false;
    let lineRevealState = { lines: [], currentIndex: 0, element: null, onComplete: null };
    let lastTouchTime = 0; // Track last touch time to prevent double-firing
    let filmByTimeouts = []; // Track 6BDM animation timeouts
    let currentTypingInterval = null; // Track the current subtitle typing interval
    let shouldContinueTyping = true; // Flag to control if typing should continue
    let timelineRevealState = { sections: [], currentIndex: 0, element: null, onComplete: null };
    let isInTimelineRevealMode = false;
    let audioContextUnlocked = false; // Track if audio context is unlocked

    // Test if a specific photo file exists
    function testPhotoExists(keyword, format) {
      return new Promise((resolve) => {
        const testImg = new Image();
        const timeout = setTimeout(() => {
          resolve(false);
        }, 1000);
        
        testImg.onload = () => {
          clearTimeout(timeout);
          resolve(true);
        };
        testImg.onerror = () => {
          clearTimeout(timeout);
          resolve(false);
        };
        testImg.src = `photos/photo_${keyword}.${format}`;
      });
    }

    // Scan photos folder to find available photo_keyword files
    async function scanAvailableKeywords() {
      const formats = ['webp', 'jpg', 'jpeg', 'png', 'gif'];
      const keywords = new Set();
      
      // Common keywords to test based on the content
      const testKeywords = [
        'ignorant', 'assange', 'wikileaks', 'bitcoin', 'crypto', 'cryptocurrency', 'blockchain',
        'surveillance', 'privacy', 'freedom', 'journalism', 'truth', 'transparency',
        'government', 'state', 'power', 'control', 'censorship', 'propaganda',
        'war', 'military', 'diplomacy', 'leaks', 'documents', 'secrets',
        'collateral', 'murder', 'video', 'footage', 'evidence',
        'prosecution', 'trial', 'prison', 'embassy', 'asylum', 'extradition',
        'moreno', 'ecuador', 'britain', 'america', 'cia', 'fbi', 'nsa',
        'cypherpunk', 'anonymity', 'encryption', 'decentralization', 'resistance',
        'activist', 'whistleblower', 'expose', 'revelation', 'scandal', 'corruption'
      ];
      
      console.log('Scanning for available photo keywords...');
      
      // First, test photo_ignorant.webp specifically
      console.log('🔍 Testing photo_ignorant.webp specifically...');
      const ignorantExists = await testPhotoExists('ignorant', 'webp');
      console.log(`photo_ignorant.webp exists: ${ignorantExists}`);
      
      // Test each keyword with each format
      for (const keyword of testKeywords) {
        let found = false;
        for (const format of formats) {
          const exists = await testPhotoExists(keyword, format);
          if (exists) {
            keywords.add(keyword);
            console.log(`✅ Found: photo_${keyword}.${format}`);
            found = true;
            break; // Found this keyword, move to next
          } else {
            console.log(`❌ Not found: photo_${keyword}.${format}`);
          }
        }
        if (!found) {
          console.log(`❌ No photo found for keyword: ${keyword}`);
        }
      }
      
      availableKeywords = keywords;
      
      // Manual override for testing - force add "ignorant" if it exists
      const ignorantTest = await testPhotoExists('ignorant', 'webp');
      if (ignorantTest) {
        availableKeywords.add('ignorant');
        console.log('✅ Manually added "ignorant" to available keywords');
      }
      
      console.log(`Available photo keywords:`, Array.from(keywords));
      return keywords;
    }

    // Extract keywords from page text that have corresponding photo files
    function extractKeywords(pageText) {
      // Convert to lowercase and extract meaningful words
      const words = pageText.toLowerCase()
        .replace(/[^\w\s]/g, ' ') // Remove punctuation
        .split(/\s+/)
        .filter(word => word.length > 3) // Only words longer than 3 characters
        .filter(word => !['that', 'this', 'with', 'from', 'they', 'have', 'been', 'were', 'said', 'will', 'would', 'could', 'should', 'about', 'above', 'below', 'under', 'over', 'through', 'during', 'before', 'after', 'while', 'since', 'until', 'unless', 'because', 'although', 'though', 'however', 'therefore', 'moreover', 'furthermore', 'nevertheless', 'nonetheless'].includes(word)) // Filter out common words
        .filter(word => availableKeywords.has(word)); // Only return words that have corresponding photo files
      
      return [...new Set(words)]; // Remove duplicates
    }

    // Simple image function - disabled for performance (no images available)
    function showImage(pageIndex) {
      // Hide all existing images first
      document.querySelectorAll('#page img').forEach(img => {
img.className = '';
      });
      
      // Skip image loading entirely since no images are available
      console.log(`📷 Image loading skipped for page ${pageIndex + 1} - no images available`);
      
      let imgEl = null; // No image element since none exist
      
      // Since no images exist, always use IMG_OFF mode for text layout
adjustTextContainerWidth(IMG_OFF);
    }
    
    
    // Adjust text container when side image is active
    function adjustTextForSideImage() {
      adjustTextContainerWidth(IMG_SIDE);
    }
    
    // Reset text container when image is turned off
    function resetTextContainer() {
      adjustTextContainerWidth(IMG_OFF);
    }
    
    // Adjust text container width based on image mode
    function adjustTextContainerWidth(imageMode) {
      const textWrap = document.getElementById('text-wrap');
      if (!textWrap) return;
      
   if (imageMode === IMG_SIDE) {
  // Side mode: text on left, image on right
  textWrap.style.setProperty('width', '50%', 'important');
  textWrap.style.setProperty('max-width', '50%', 'important');
  textWrap.style.setProperty('position', 'relative', 'important');
  textWrap.style.setProperty('z-index', '2', 'important');
  textWrap.classList.add('side-mode');
  textWrap.classList.remove('small-side-mode');
 } else if (imageMode === IMG_SMALL_SIDE) {
   // Small side mode: text on left, smaller image on right
   textWrap.style.setProperty('width', '75%', 'important');
   textWrap.style.setProperty('max-width', '75%', 'important');
   textWrap.style.setProperty('position', 'relative', 'important');
   textWrap.style.setProperty('z-index', '2', 'important');
   textWrap.classList.add('small-side-mode');
   textWrap.classList.remove('side-mode');
 } else {
  // All other modes: text uses full width
  textWrap.style.setProperty('width', '100%', 'important');
  textWrap.style.setProperty('max-width', '100%', 'important');
  textWrap.style.setProperty('position', '', 'important');
  textWrap.style.setProperty('z-index', '', 'important');
  textWrap.classList.remove('side-mode');
  textWrap.classList.remove('small-side-mode');
}
    }
    
    
    // Create image for a page number - tries multiple formats and naming patterns
    function createImageForPage(pageNumber) {
      const img = document.createElement('img');
      img.id = `img-${pageNumber}`;
      img.alt = `Page ${pageNumber} Image`;
      
      // Start invisible - only show when successfully loaded
      img.style.opacity = '0';
      img.style.transition = 'opacity 0.2s ease-in-out';
      
      // Add to page first (invisible)
      document.getElementById('page').appendChild(img);
      
      // Try to find any image that starts with the page number
      findImageForPage(img, pageNumber);
      
      // Only show image when it loads successfully
      img.addEventListener('load', () => {
        console.log(`Image loaded successfully for page ${pageNumber}`);
        img.style.opacity = '0.765';

        // Update page mode and layout if this is the current page
        const pageIndex = pageNumber - 1;
        if (pageIndex === currentPage) {
          adjustTextContainerWidth(pageModes[pageIndex]);
        }

        // Apply current overlay mode to new image
        applyOverlayToImage(img, currentOverlayMode);
      });
      
      // Handle image loading errors gracefully
      img.addEventListener('error', () => {
        console.log(`Failed to load image for page ${pageNumber}`);
        img.style.display = 'none';
      });
      
      return img;
    }
    
    // Find any image that starts with the page number
    function findImageForPage(img, pageNumber) {
      const formats = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'tiff', 'tif', 'avif', 'jfif', 'pjpeg'];
      
      // Try different naming patterns for this page number
      const namingPatterns = [
        `photo${pageNumber}`,           // photo10.jpg
        `picture${pageNumber}`,         // picture10.jpg
        `photo${pageNumber}_collateral`, // photo10_collateral.jpg
        `picture${pageNumber}_collateral`, // picture10_collateral.jpg
        `photo${pageNumber}_`,          // photo10_anything.jpg
        `picture${pageNumber}_`         // picture10_anything.jpg
      ];
      
      // Try each naming pattern with each format
      for (const pattern of namingPatterns) {
        for (const format of formats) {
          const testSrc = `photos/${pattern}.${format}`;
          const testImg = new Image();
          
          testImg.onload = function() {
            console.log(`✅ Found working image: ${testSrc}`);
            img.src = testSrc;
            return; // Stop trying once we find one
          };
          
          testImg.onerror = function() {
            // Continue trying other patterns/formats
          };
          
          testImg.src = testSrc;
        }
      }
      
      // If no specific pattern worked, try a more general approach
      // This will try to find any file that starts with the page number
      setTimeout(() => {
        if (!img.src) {
          console.log(`Trying general search for page ${pageNumber}...`);
          tryGeneralImageSearch(img, pageNumber, formats);
        }
      }, 100);
    }
    
    // Try to find any image file that starts with the page number
    function tryGeneralImageSearch(img, pageNumber, formats) {
      // Common prefixes to try
      const prefixes = ['photo', 'picture', 'img', 'image'];
      
      for (const prefix of prefixes) {
        for (const format of formats) {
          // Try exact match first
          const exactSrc = `photos/${prefix}${pageNumber}.${format}`;
          const testImg = new Image();
          
          testImg.onload = function() {
            console.log(`✅ Found working image (exact): ${exactSrc}`);
            img.src = exactSrc;
            return;
          };
          
          testImg.onerror = function() {
            // Try with underscore and common suffixes
            const suffixes = ['_collateral', '_murder', '_video', '_footage', '_evidence'];
            for (const suffix of suffixes) {
              const suffixSrc = `photos/${prefix}${pageNumber}${suffix}.${format}`;
              const suffixTestImg = new Image();
              
              suffixTestImg.onload = function() {
                console.log(`✅ Found working image (with suffix): ${suffixSrc}`);
                img.src = suffixSrc;
                return;
              };
              
              suffixTestImg.onerror = function() {
                // Continue trying
              };
              
              suffixTestImg.src = suffixSrc;
            }
          };
          
          testImg.src = exactSrc;
        }
      }
    }

    // Create image for keyword-based matching
    function createImageForKeyword(keyword) {
      const img = document.createElement('img');
      img.id = `img-${keyword}`;
      img.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
height: 100%;
        object-fit: cover;
        z-index: -1;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
      `;
      
      // Try different image formats for the keyword
      tryImageFormats(img, keyword, 0);
      
      // Only show image when it loads successfully
      img.addEventListener('load', () => {
        console.log(`Image loaded successfully for keyword: ${keyword}`);
        img.style.opacity = '0.765';

        // Update page mode and layout if this is the current page
        const pageIndex = currentPage;
        if (pageIndex === currentPage) {
          adjustTextContainerWidth(pageModes[pageIndex]);
        }

        // Apply current overlay mode to new image
        applyOverlayToImage(img, currentOverlayMode);
      });

      // Handle image loading errors gracefully
      img.addEventListener('error', () => {
        console.log(`Failed to load image for keyword: ${keyword}`);
        img.style.display = 'none';
      });

      return img;
    }


         // Universal image support - tries all possible formats
     function tryImageFormats(img, keyword, formatIndex) {
       
       // Start with most compatible formats, then try everything else
       const formats = [
 'jpg', 'jpeg', 'png', 'gif',  // Universal support
 'webp', 'svg',// Modern browsers
 'bmp', 'tiff', 'tif', // Desktop browsers
 'avif', 'jfif', 'pjpeg'       // Newer formats
       ];
       
       if (formatIndex >= formats.length) {
 // All formats failed, remove the image
 console.log(`No image found for keyword '${keyword}'`);
 img.remove();
 return;
       }
       
       const format = formats[formatIndex];
       const testSrc = `photos/photo_${keyword}.${format}`;
       
       // Test if this format file exists by creating a test image
       const testImg = new Image();
       testImg.onload = function() {
 // File exists and format is supported - use it!
 console.log(`✅ Found working image: ${testSrc}`);
 img.src = testSrc;
       };
       testImg.onerror = function() {
 // This format/file doesn't work, try next
 tryImageFormats(img, keyword, formatIndex + 1);
       };
       testImg.src = testSrc;
     }

    /* ================== OVERFLOW DETECTION & AUTO-SLIDE CREATION ================== */
    function checkTextOverflow(element, text) {
      console.log('🔍 CHECKING OVERFLOW FOR:', text.substring(0, 100) + '...');
      
      // Create a temporary element that exactly matches the real element's styling
      const tempElement = element.cloneNode(false);
      tempElement.style.cssText = getComputedStyle(element).cssText;
      tempElement.style.position = 'absolute';
      tempElement.style.top = '-9999px';
      tempElement.style.left = '-9999px';
      tempElement.style.visibility = 'hidden';
      tempElement.style.height = 'auto';
      tempElement.style.maxHeight = 'none';
      tempElement.style.overflow = 'visible';
      tempElement.textContent = text;
      
      // Add to DOM for measurement
      document.body.appendChild(tempElement);
      
      // Force reflow
      tempElement.offsetHeight;
      
      // Get precise measurements
      const tempRect = tempElement.getBoundingClientRect();
      const textHeight = tempRect.height;
      
      // Remove temp element
      document.body.removeChild(tempElement);
      
      // Get available space (from text container to navbar)
      const textWrapEl = document.getElementById('text-wrap');
      const nav = document.getElementById('nav');
      
      if (!nav || !textWrapEl) {
        console.log('❌ Required elements not found');
        return false;
      }
      
      const textWrapRect = textWrapEl.getBoundingClientRect();
      const navRect = nav.getBoundingClientRect();
      
      // Calculate available height with safety margins
      const availableHeight = navRect.top - textWrapRect.top - 80; // 80px safety buffer
      const wouldOverflow = textHeight > availableHeight;
      
      console.log(`📏 Enhanced overflow check:
        - Text height: ${textHeight}px
        - Available height: ${availableHeight}px
        - Text wrap top: ${textWrapRect.top}px
        - Nav top: ${navRect.top}px
        - Would overflow: ${wouldOverflow}`);
      
      return wouldOverflow;
    }
    
    function splitOverflowingText(text) {
      const lines = text.split('\n');
      const slides = [];
      let currentSlide = '';
      
      // Create a test element that exactly matches the real element
      const realElement = document.getElementById('unscramble');
      const testElement = realElement.cloneNode(false);
      
      // Copy all computed styles exactly
      const computedStyle = getComputedStyle(realElement);
      testElement.style.cssText = computedStyle.cssText;
      testElement.style.position = 'absolute';
      testElement.style.top = '-9999px';
      testElement.style.left = '-9999px';
      testElement.style.visibility = 'hidden';
      testElement.style.height = 'auto';
      testElement.style.maxHeight = 'none';
      testElement.style.overflow = 'visible';
      
      document.body.appendChild(testElement);
      
      // Get available space measurements
      const textWrapEl = document.getElementById('text-wrap');
      const nav = document.getElementById('nav');
      
      if (!nav || !textWrapEl) {
        console.log('❌ Required elements not found for splitting');
        document.body.removeChild(testElement);
        return [text]; // Return original text if measurement fails
      }
      
      const textWrapRect = textWrapEl.getBoundingClientRect();
      const navRect = nav.getBoundingClientRect();
      const maxHeight = navRect.top - textWrapRect.top - 80; // 80px safety buffer
      
      console.log(`📄 Text splitting with max height: ${maxHeight}px`);
      
      for (let i = 0; i < lines.length; i++) {
        const lineToAdd = currentSlide ? currentSlide + '\n' + lines[i] : lines[i];
        testElement.textContent = lineToAdd;
        
        // Force reflow and measure
        testElement.offsetHeight;
        const testHeight = testElement.getBoundingClientRect().height;
        
        if (testHeight > maxHeight && currentSlide) {
          // Current slide would overflow, save it and start new one
          slides.push(currentSlide.trim());
          console.log(`📄 Slide ${slides.length} saved: ${testHeight}px would exceed ${maxHeight}px`);
          
          // Start new slide with the current line
          currentSlide = lines[i];
          console.log(`📄 Slide ${slides.length + 1} started with: "${lines[i].substring(0, 50)}..."`);
        } else {
          // Line fits, add it to current slide
          currentSlide = lineToAdd;
        }
      }
      
      // Add the last slide
      if (currentSlide.trim()) {
        slides.push(currentSlide.trim());
        console.log(`📄 Final slide ${slides.length} added`);
      }
      
      document.body.removeChild(testElement);
      console.log(`📄 Text split into ${slides.length} slides total`);
      return slides;
    }
    
      function truncateTextToFit(element, text) {
      // Check if text overflows
      if (checkTextOverflow(element, text)) {
        console.log('Text overflow detected, splitting into multiple slides...');
        
        // Split the overflowing text
        const splitSlides = splitOverflowingText(text);
        
        if (splitSlides.length > 1) {
          console.log(`📄 OVERFLOW DETECTED: Text split into ${splitSlides.length} slides`);
          console.log(`📄 Slide 1 preview: "${splitSlides[0].substring(0, 100)}..."`);
          console.log(`📄 Slide 2 preview: "${splitSlides[1].substring(0, 100)}..."`);
          
          // Find the current page index
          const currentPageIndex = currentPage;
          
          // Replace the current page content with the first slide
          pages[currentPageIndex] = splitSlides[0];
          
          // Insert additional slides after the current page
          for (let i = 1; i < splitSlides.length; i++) {
            pages.splice(currentPageIndex + i, 0, splitSlides[i]);
            pageModes.splice(currentPageIndex + i, 0, IMG_BG);
            console.log(`📄 Inserted slide ${i + 1} at position ${currentPageIndex + i}`);
          }
          
          // Update the slide counter
          slideCounterEl.textContent = `SLIDE ${currentPageIndex + 1} / ${pages.length}`;
          
          console.log(`📄 Total slides now: ${pages.length}`);
        }
      }
      
      // Set the content (either original or first split slide)
      element.textContent = text;
      }

    /* ================== SCRAMBLE ================== */
    
    // Function to type subtitle text character by character (typewriter effect)
    function decodeSubtitle(element, baseText, subtitleText, onComplete) {
      // Check if we should even start typing (page might have changed)
      if (!shouldContinueTyping) {
        console.log('🛑 Typing cancelled - page navigation detected');
        return;
      }
      
      // Clear any existing typing animation first
      if (currentTypingInterval) {
        clearInterval(currentTypingInterval);
        currentTypingInterval = null;
        console.log('🧹 Cleared previous typing animation');
      }
      
      let charIndex = 0;
      const len = subtitleText.length;
      
      console.log('Starting subtitle typewriter animation...');
      
      currentTypingInterval = setInterval(() => {
        // Check if we should continue typing
        if (!shouldContinueTyping) {
          console.log('🛑 Typing cancelled mid-animation');
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
          return;
        }
        
        // Show characters up to current index
        const currentText = subtitleText.substring(0, charIndex + 1);
        element.textContent = baseText + currentText;
        
        // Play a subtle beep for typing (less frequent than decode beeps)
        if (charIndex % 3 === 0) { // Every 3rd character
          playBeep(1000, 0.02, 0.08); // Higher pitch, shorter duration, quieter
        }
        
        charIndex++;
        if (charIndex >= len) {
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
          element.textContent = baseText + subtitleText; // Final clean text
          console.log('Subtitle typewriter complete');
          if (shouldContinueTyping) { // Only call onComplete if we weren't cancelled
          onComplete && onComplete();
          }
        }
      }, 50); // 50ms per character for smooth typewriter effect
    }
    
    // Function to decode individual timeline lines with scrambling effect
    function decodeTimelineLine(element, baseContent, lineText, onComplete) {
      let index = 0;
      const chunkSize = 15; // Larger chunks for much faster decoding
      const len = lineText.length;
      let scrambled = lineText.split('');
      
      // Initialize scrambled version (keeping spaces and punctuation)
      for (let i = 0; i < len; i++) {
        scrambled[i] = /\s|[:\.\-\[\]#]/.test(lineText[i]) ? lineText[i] : chars[Math.floor(Math.random() * chars.length)];
      }
      
      const lineInterval = setInterval(() => {
        const display = scrambled.slice();
        
        // Reveal chunks progressively
        for (let i = 0; i < index; i++) {
          let s = i * chunkSize, e = Math.min(s + chunkSize, len);
          for (let j = s; j < e; j++) display[j] = lineText[j];
        }
        
        // Keep scrambling the unrevealed part
        for (let k = index * chunkSize; k < len; k++) {
          display[k] = /\s|[:\.\-\[\]#]/.test(lineText[k]) ? lineText[k] : chars[Math.floor(Math.random() * chars.length)];
        }
        
        // Update element with base content + decoded line
        element.textContent = baseContent + display.join('');
        
        // Play synchronized beep for this chunk
        playDecodingBeeps(index, Math.ceil(len / chunkSize));
        
        index++;
        if ((index * chunkSize) >= len) {
          clearInterval(lineInterval);
          element.textContent = baseContent + lineText; // Final clean text
          onComplete && onComplete();
        }
      }, 20); // Much faster decode for individual lines
    }
    
    function scrambleFastChunks(element, text, onComplete) {
      if (currentInterval) {
clearInterval(currentInterval);
currentInterval = null;
      }
      
      let index = 0, chunkSize = 15, scrambled = text.split(''), len = text.length;
      for (let i=0;i<len;i++) scrambled[i] = /\s/.test(text[i]) ? text[i] : chars[Math.floor(Math.random()*chars.length)];
      isAnimating = true; promptElem.style.visibility='hidden'; navMsg.style.visibility='hidden';

      // Calculate total chunks for audio sync
      const totalChunks = Math.ceil(len / chunkSize);
      
      // Initialize audio context on first user interaction
      initAudioContext();

      currentInterval = setInterval(() => {
const display = scrambled.slice();
for (let i=0;i<index;i++){
  let s=i*chunkSize, e=Math.min(s+chunkSize,len);
  for (let j=s;j<e;j++) display[j]=text[j];
}
for (let k=index*chunkSize;k<len;k++) display[k] = /\s/.test(text[k]) ? text[k] : chars[Math.floor(Math.random()*chars.length)];
element.textContent = display.join('');

// Play synchronized beep for this chunk
playDecodingBeeps(index, totalChunks);

index++;
if ((index*chunkSize)>=len){
  clearInterval(currentInterval);
  currentInterval = null;
  truncateTextToFit(element, text);
  isAnimating=false;
  
  // Only show "PRESS SPACEBAR TO CONTINUE" for first 2 pages
  if (currentPage < 2) {
  navMsg.innerHTML='PRESS SPACEBAR<br>TO CONTINUE';
  navMsg.style.fontSize = '0.9rem';
  navMsg.style.visibility='visible';
  }
  
  // Check if this text contains "A FILM BY" and add delayed subtitle
  if (text.includes('A FILM BY EUGENE JARECKI') && text.includes('6BDM: JULIAN ASSANGE')) {
    console.log('A FILM BY + 6BDM detected - showing delayed subtitle...');
    
    // Show JA_OBIWAN video
    showVideo3Background();
    
    // Enable typing for this specific animation
    shouldContinueTyping = true;
    
    // First show only "A FILM BY EUGENE JARECKI"
    const filmByText = text.split('\n\n6BDM:')[0];
    element.textContent = filmByText;
    
    // After 18 seconds, decode the subtitle
    const subtitleTimeout = setTimeout(() => {
      // Check if we should still continue (page might have changed)
      if (!shouldContinueTyping) {
        console.log('🛑 6BDM animation cancelled - page changed');
        return;
      }
      
      console.log('Starting 6BDM subtitle decode after 18 second delay');
      
      // Extract the 6BDM part
      const subtitleText = '\n\n6BDM: JULIAN ASSANGE AND THE PRICE OF TRUTH';
      const baseText = filmByText;
      
      // Decode the subtitle with scrambling effect
      decodeSubtitle(element, baseText, subtitleText, () => {
        // Continue to next slide after subtitle decode completes
        const continueTimeout = setTimeout(() => {
          onComplete && onComplete();
        }, 1000); // Brief pause before continuing
        filmByTimeouts.push(continueTimeout);
      });
    }, 20000); // 20 second delay for subtitle
    filmByTimeouts.push(subtitleTimeout);
  } else if (text.includes('A FILM BY EUGENE JARECKI')) {
    console.log('A FILM BY detected - adding 5 second delay before continuing...');
    const filmByTimeout = setTimeout(() => {
      onComplete && onComplete();
    }, 5000); // 5 second delay
    filmByTimeouts.push(filmByTimeout);
  } else {
    onComplete && onComplete();
  }
}
      },100);
    }

    // Ultra-fast scrambling specifically for 2006 text - much faster interval
    function scrambleUltraFastChunks(element, text, onComplete) {
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      let index = 0, chunkSize = 15, scrambled = text.split(''), len = text.length;
      for (let i=0;i<len;i++) scrambled[i] = /\s/.test(text[i]) ? text[i] : chars[Math.floor(Math.random()*chars.length)];
      isAnimating = true; promptElem.style.visibility='hidden'; navMsg.style.visibility='hidden';

      // Calculate total chunks for audio sync
      const totalChunks = Math.ceil(len / chunkSize);
      
      // Initialize audio context on first user interaction
      initAudioContext();

      currentInterval = setInterval(() => {
        const display = scrambled.slice();
        for (let i=0;i<index;i++){
          let s=i*chunkSize, e=Math.min(s+chunkSize,len);
          for (let j=s;j<e;j++) display[j]=text[j];
        }
        for (let k=index*chunkSize;k<len;k++) display[k] = /\s/.test(text[k]) ? text[k] : chars[Math.floor(Math.random()*chars.length)];
        element.textContent = display.join('');

        // Play synchronized beep for this chunk
        playDecodingBeeps(index, totalChunks);

        index++;
        if ((index*chunkSize)>=len){
          clearInterval(currentInterval);
          currentInterval = null;
          truncateTextToFit(element, text);
          isAnimating=false;
          
          // Only show "PRESS SPACEBAR TO CONTINUE" for first 2 pages
          if (currentPage < 2) {
            navMsg.innerHTML='PRESS SPACEBAR<br>TO CONTINUE';
            navMsg.style.fontSize = '0.9rem';
            navMsg.style.visibility='visible';
          }
          
          onComplete && onComplete();
        }
      }, 25); // Ultra-fast: 25ms interval instead of 100ms (4x faster)
    }

    /* ================== TIMELINE YEAR-BY-YEAR REVEAL ================== */
    function revealTimelineYearByYear(element, text, onComplete) {
      // Clear any existing animations
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      isAnimating = true;
      isInTimelineRevealMode = true;
      promptElem.style.visibility = 'hidden';
      
      // Split timeline into year sections
      const yearSections = parseTimelineSections(text);
      
      // Set up timeline reveal state
      timelineRevealState = {
        sections: yearSections,
        currentIndex: 0,
        element: element,
        onComplete: onComplete
      };
      
      console.log('Starting year-by-year timeline reveal...');
      console.log(`Total year sections: ${yearSections.length}`);
      
      // Clear element and show first year section with decode animation
      element.textContent = '';
      showNextTimelineSection();
    }
    
    function parseTimelineSections(text) {
      // Split by year patterns (2006:, 2010:, etc.)
      const yearPattern = /(\d{4}(-\d{4})?:\s*)/g;
      const sections = [];
      
      // Find all year markers
      const matches = [...text.matchAll(yearPattern)];
      
      if (matches.length === 0) {
        // No year patterns found, return whole text as single section
        return [text];
      }
      
      // Split text at each year marker
      let lastIndex = 0;
      matches.forEach((match, i) => {
        if (i > 0) {
          // Extract section from previous year to current year
          const sectionText = text.substring(lastIndex, match.index).trim();
          if (sectionText) {
            sections.push(sectionText);
          }
        }
        lastIndex = match.index;
      });
      
      // Add the last section
      const finalSection = text.substring(lastIndex).trim();
      if (finalSection) {
        sections.push(finalSection);
      }
      
      console.log('Parsed timeline sections:', sections.map(s => s.substring(0, 50) + '...'));
      return sections;
    }
    
    function showNextTimelineSection() {
      if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
        const currentSection = timelineRevealState.sections[timelineRevealState.currentIndex];
        const sectionNumber = timelineRevealState.currentIndex + 1;
        
        
        if (timelineRevealState.currentIndex === 0) {
          // First section (2006): decode with ultra-fast scrambling animation
          scrambleUltraFastChunks(timelineRevealState.element, currentSection, () => {
            timelineRevealState.currentIndex++;
            // Show navigation message for next section
            if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
              navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
              navMsg.style.fontSize = '0.9rem';
              navMsg.style.visibility = 'visible';
            } else {
              // All sections revealed
              finishTimelineReveal();
            }
          });
        } else {
          // Subsequent sections: append instantly with single line break
          const currentContent = timelineRevealState.element.textContent;
          timelineRevealState.element.textContent = currentContent + '\n' + currentSection;
          
          timelineRevealState.currentIndex++;
          
          // Show navigation message for next section
          if (timelineRevealState.currentIndex < timelineRevealState.sections.length) {
            navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
            navMsg.style.fontSize = '0.9rem';
            navMsg.style.visibility = 'visible';
          } else {
            // All sections revealed
            finishTimelineReveal();
          }
        }
      }
    }
    
    function finishTimelineReveal() {
      console.log('All timeline sections revealed, finishing...');
      isAnimating = false;
      isInTimelineRevealMode = false;
      navMsg.style.visibility = 'hidden';
      timelineRevealState.onComplete && timelineRevealState.onComplete();
    }

    /* ================== LINE BY LINE REVEAL ================== */
    function revealLineByLine(element, text, onComplete) {
      // Clear any existing intervals and timeouts
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
      }
      
      // Clear any existing line reveal timeouts
      lineRevealTimeouts.forEach(timeout => clearTimeout(timeout));
      lineRevealTimeouts = [];
      
      isAnimating = true;
      isInLineRevealMode = true;
      promptElem.style.visibility = 'hidden';
      
      const lines = text.split('\n').filter(line => line.trim() !== ''); // Remove empty lines
      element.textContent = '';
      
      // Set up line reveal state
      lineRevealState = {
        lines: lines,
        currentIndex: 0,
        element: element,
        onComplete: onComplete
      };
      
      console.log('Starting manual line-by-line reveal for 2006-2024 content...');
      console.log(`Total lines to reveal: ${lines.length}`);
      
      // Show the first line immediately
      showNextLineManual();
    }
    
    function showNextLineManual() {
      if (lineRevealState.currentIndex < lineRevealState.lines.length) {
        const currentLine = lineRevealState.lines[lineRevealState.currentIndex];
        const lineNumber = lineRevealState.currentIndex + 1;
        
        // Determine if this line should be decoded (only first line - first item only)
        const shouldDecode = lineRevealState.currentIndex === 0;
        
        if (shouldDecode) {
          console.log(`Decoding line ${lineNumber}: "${currentLine}"`);
          
          // Get current content before this line
          let previousContent = '';
          if (lineRevealState.currentIndex > 0) {
            previousContent = lineRevealState.element.textContent + '\n\n';
          }
          
          // Decode this line with scrambling effect
          decodeTimelineLine(lineRevealState.element, previousContent, currentLine, () => {
            lineRevealState.currentIndex++;
            
            // Check if we're done
            if (lineRevealState.currentIndex >= lineRevealState.lines.length) {
              console.log('All lines revealed, finishing...');
              isAnimating = false;
              isInLineRevealMode = false;
              lineRevealState.onComplete && lineRevealState.onComplete();
            } else {
              // Show navigation message for manual progression (even after decoded lines)
              navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
              navMsg.style.fontSize = '0.9rem';
              navMsg.style.visibility = 'visible';
            }
          });
        } else {
          // Show instantly for later lines (no decoding)
          if (lineRevealState.currentIndex > 0) {
            lineRevealState.element.textContent += '\n\n';
          }
          lineRevealState.element.textContent += currentLine;
          
          console.log(`Instantly revealed line ${lineNumber}: "${currentLine}"`);
          lineRevealState.currentIndex++;
          
          // Show navigation message for manual progression
          navMsg.innerHTML = 'PRESS SPACEBAR<br>TO CONTINUE';
          navMsg.style.fontSize = '0.9rem';
          navMsg.style.visibility = 'visible';
          
          if (lineRevealState.currentIndex >= lineRevealState.lines.length) {
            // All lines revealed
            console.log('All lines revealed, finishing...');
            isAnimating = false;
            isInLineRevealMode = false;
            lineRevealState.onComplete && lineRevealState.onComplete();
          }
        }
      }
    }

         /* ================== PAGE RENDER ================== */
  function startPage(pageIndex){
        if (pageIndex >= pages.length) pageIndex = 0;
        if (pageIndex < 0) pageIndex = pages.length - 1;
        currentPage = pageIndex;
        
        // Clear any ongoing line reveal timeouts when changing pages
        lineRevealTimeouts.forEach(timeout => clearTimeout(timeout));
        lineRevealTimeouts = [];
        
        // Clear any ongoing 6BDM animation timeouts
        filmByTimeouts.forEach(timeout => clearTimeout(timeout));
        filmByTimeouts = [];
        
        // Clear any ongoing typing animation
        if (currentTypingInterval) {
          clearInterval(currentTypingInterval);
          currentTypingInterval = null;
        }
        
        // Stop any typing animations that might be about to start
        shouldContinueTyping = false;
        
        // Clear any running scrambling animation
        if (currentInterval) {
          clearInterval(currentInterval);
          currentInterval = null;
        }
        
        // Reset animation state
        isAnimating = false;
        
        // Reset line reveal mode
        isInLineRevealMode = false;
        
        // Reset timeline reveal mode
        isInTimelineRevealMode = false;
        
        slideCounterEl.textContent = `SLIDE ${pageIndex + 1} / ${pages.length}`;
        navMsg.style.visibility = 'hidden';
        
        // Set data-page attribute for CSS targeting
        pageEl.setAttribute('data-page', pageIndex + 1);
        
       
      // Use simple, consistent font sizing - smaller on mobile
        const isMobile = window.innerWidth <= 768;
        
        // Check if this is timeline content first
        const pageContent = pages[pageIndex];
        const isTimelineContent = pageContent.includes('2006:') || 
                                 pageContent.includes('2010:') || 
                                 pageContent.includes('2011-2012:') || 
                                 pageContent.includes('2017:') || 
                                 pageContent.includes('2017-2024:') || 
                                 pageContent.includes('2024:') || 
                                 pageContent.includes('RETURNED TO AUSTRALIA');
        
        if (isTimelineContent) {
          // Make timeline content 25% smaller
          el.style.fontSize = isMobile ? '0.6rem' : '0.9rem';
          
          // Mark as timeline content for CSS protection
          el.setAttribute('data-timeline', 'true');
          
          // Preserve exact formatting for timeline content - prevent any text modifications
          el.style.whiteSpace = 'pre-wrap';
          el.style.wordWrap = 'normal';
          el.style.overflowWrap = 'normal';
          el.style.hyphens = 'none';
          el.style.textIndent = '0';
          el.style.wordBreak = 'normal';
          el.style.lineHeight = '1.5';
          
        } else {
          // Normal text size
        el.style.fontSize = isMobile ? '0.8rem' : '1.2rem';
          
          // Remove timeline marker
          el.removeAttribute('data-timeline');
          
          // Reset any timeline-specific formatting
          el.style.whiteSpace = '';
          el.style.wordWrap = '';
          el.style.overflowWrap = '';
          el.style.hyphens = '';
          el.style.textIndent = '';
          el.style.wordBreak = '';
          el.style.lineHeight = '';
        }
        
        el.style.paddingBottom = ''; // Reset any padding
       
       // Show text for all pages
       if (pageIndex < pages.length) {
         const textWrap = document.getElementById('text-wrap');
         if (textWrap) {
           textWrap.style.display = 'block';
         }
         
         el.textContent='';
         isAnimating = false;
         
         // Remove any existing animation classes
         el.classList.remove('collateral-murder-slide');
         
         // Check if this is the Collateral Murder video slide
         const isCollateralMurderSlide = pages[pageIndex].includes('It published the infamous Collateral Murder video in 2010');
         
         if (isTimelineContent) {
          // For timeline content, use year-by-year reveal system
          console.log('Timeline content detected, starting year-by-year reveal');
          
          // Use the new year-by-year timeline reveal
          revealTimelineYearByYear(el, pages[pageIndex], () => {
             // Timeline reveal complete
            console.log('Timeline year-by-year reveal completed');
           });
         } else {
           // Skip overflow checking for page 0 to speed up initial load
           if (pageIndex !== 0 && checkTextOverflow(el, pages[pageIndex])) {
             
             // Split the content first
             const splitSlides = splitOverflowingText(pages[pageIndex]);
             
             if (splitSlides.length > 1) {
               
               // Replace current page with first slide
               pages[pageIndex] = splitSlides[0];
               
               // Insert additional slides after current page
               for (let i = 1; i < splitSlides.length; i++) {
                 pages.splice(pageIndex + i, 0, splitSlides[i]);
                 pageModes.splice(pageIndex + i, 0, IMG_BG);
               }
               
               // Update slide counter
               slideCounterEl.textContent = `SLIDE ${pageIndex + 1} / ${pages.length}`;
             }
           }
           
           // Use faster scrambling for page 0
           if (pageIndex === 0) {
             // Instant display for page 0 to speed up initial load
             el.textContent = pages[pageIndex];
             // Call the callback immediately
             if (isCollateralMurderSlide) {
               console.log('Collateral Murder slide detected, starting animation...');
               setTimeout(() => {
                 el.classList.add('collateral-murder-slide');
                 console.log('Animation class added');
                 setTimeout(() => {
                   createPersistentText();
                   console.log('Persistent text created');
                 }, 3000);
               }, 1000);
             }
         } else {
           scrambleFastChunks(el, pages[pageIndex], () => {
           // Text displayed
           if (isCollateralMurderSlide) {
             console.log('Collateral Murder slide detected, starting animation...');
             // Add animation class after text is fully displayed
             setTimeout(() => {
               el.classList.add('collateral-murder-slide');
               console.log('Animation class added');
               
               // After animation completes, create a persistent copy
               setTimeout(() => {
                 createPersistentText();
                 console.log('Persistent text created');
               }, 3000); // After 3 second animation
             }, 1000); // Wait 1 second after text is displayed
           }
         });
           }
         }
       }
       
       showImage(pageIndex);
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 7) {
         console.log('🔇 Audio disabled for page 7');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 10) {
         console.log('🔇 Audio disabled for page 10');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 9) {
         console.log('🔇 Audio disabled for page 9');
       }
       
       // Audio disabled - no sounds
       if (pageIndex + 1 === 13) {
         console.log('🔇 Audio disabled for page 13');
       }
       
      // Audio disabled - no sounds
      if (pageIndex + 1 === 15) {
        console.log('🔇 Audio disabled for page 15');
      }
       
       // Show video on slide 15
       console.log(`🔍 Debug: Current page ${pageIndex + 1}, checking for video on slide 15...`);
       if (pageIndex + 1 === 15) {
         console.log('🎬 SLIDE 15 - Showing video...');
         showVideoBackground();
         // Hide video2 when showing video15
         hideVideo2Background();
       } else {
         console.log(`🎬 Not slide 15 (current: ${pageIndex + 1}), hiding video...`);
         // Hide video on other pages
         hideVideoBackground();
       }
       
       // Show video2 on slide 2
       console.log(`🔍 Debug: Current page ${pageIndex + 1}, checking for video2 on slide 2...`);
       if (pageIndex + 1 === 2) {
         console.log('🎬 SLIDE 2 - Showing video2...');
         showVideo2Background();
       } else {
         console.log(`🎬 Not slide 2 (current: ${pageIndex + 1}), hiding video2...`);
         // Hide video2 on other pages
         hideVideo2Background();
       }
       
       // Hide video3 on all pages (it only shows during A FILM BY animation)
       hideVideo3Background();
     }

    // Create persistent text that stays on screen
    function createPersistentText() {
      // Remove any existing persistent text
      const existing = document.getElementById('persistent-text');
      if (existing) {
        existing.remove();
      }
      
      // Create new persistent text element
      const persistentDiv = document.createElement('div');
      persistentDiv.id = 'persistent-text';
      
      const textContent = document.createElement('div');
      textContent.className = 'text-content';
      textContent.textContent = 'It published the infamous Collateral Murder video in 2010';
      
      persistentDiv.appendChild(textContent);
      document.body.appendChild(persistentDiv);
     }

    /* ================== NAV ================== */
    let lastAdvance = 0;
    function throttle(){ const now=Date.now(); if (now-lastAdvance<300) return false; lastAdvance=now; return true; }
    function safeAdvance(){ if (!throttle()) return; unlockAudioContext(); startPage(currentPage+1); }
    function goBack(){ if (!throttle()) return; unlockAudioContext(); startPage(currentPage-1); }

    document.getElementById('nav-prev').addEventListener('pointerdown', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('pointerdown', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('touchstart', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('touchstart', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('click', goBack);
    document.getElementById('nav-next').addEventListener('click', safeAdvance);
 document.addEventListener('pointerdown', (e)=>{ 
      if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
      
      // If in timeline reveal mode, clicking anywhere advances to next year section
      if (isInTimelineRevealMode) {
        showNextTimelineSection();
        return;
      }
      
      // If in line reveal mode, clicking anywhere advances to next line
      if (isInLineRevealMode) {
        showNextLineManual();
        return;
      }
      
      // Normal mode: Left half of screen goes back, right half goes forward
      if (e.clientX < window.innerWidth / 2) {
        goBack();
      } else {
        safeAdvance();
      }
    }, {passive:true});
     
     document.addEventListener('touchstart', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       const now = Date.now();
       // Debounce touch events to prevent double-firing
       if (now - lastTouchTime < 200) return;
       lastTouchTime = now;
       
       // If in timeline reveal mode, tapping anywhere advances to next year section
       if (isInTimelineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         showNextTimelineSection();
         return;
       }
       
       // If in line reveal mode, tapping anywhere advances to next line
       if (isInLineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         showNextLineManual();
         return;
       }
       
       // Normal mode: Left half of screen goes back, right half goes forward
       if (e.touches[0].clientX < window.innerWidth / 2) {
         goBack();
       } else {
         safeAdvance();
       }
     }, {passive:false}); // Changed to passive:false to allow preventDefault
     
     // Add touchend event handler for better mobile responsiveness  
     document.addEventListener('touchend', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       const now = Date.now();
       // Debounce touch events to prevent double-firing
       if (now - lastTouchTime < 200) return;
       lastTouchTime = now;
       
       // If in timeline reveal mode, tapping anywhere advances to next year section
       if (isInTimelineRevealMode) {
         console.log('Mobile touchend: Timeline reveal mode detected, advancing to next section');
         e.preventDefault(); // Prevent default touch behavior
         showNextTimelineSection();
         return;
       }
       
       // If in line reveal mode, tapping anywhere advances to next line
       if (isInLineRevealMode) {
         e.preventDefault(); // Prevent default touch behavior
         showNextLineManual();
         return;
       }
     }, {passive:false});
document.addEventListener('click', (e)=>{ 
      if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
      
      const now = Date.now();
      // Prevent click events that follow touch events too closely
      if (now - lastTouchTime < 300) return;
      
      // If in line reveal mode, clicking anywhere advances to next line
      if (isInLineRevealMode) {
        e.preventDefault(); // Prevent any default click behavior
        showNextLineManual();
        return;
      }
      
      // Normal mode: Left half of screen goes back, right half goes forward
      if (e.clientX < window.innerWidth / 2) {
        goBack();
      } else {
        safeAdvance();
      }
    });

    // Simplified font system
    let currentFontIndex = 3; // Start with Crisp (index 3) as default
    let currentFontSize = 1.0; // Size multiplier (1.0 = 100% of base size)
    const fonts = [
      { family: 'Courier New', size: '1.2rem' },
      { family: 'IBM3270', size: '1.2rem' },
      { family: 'PixelCarnageMono', size: '1.2rem' },
      { family: 'Crisp', size: '1.2rem' },
      { family: 'ProggyCleanCE', size: '1.2rem' },
      { family: 'ProggySquare', size: '1.2rem' }
    ];
    
    function cycleFontForward() {
      currentFontIndex = (currentFontIndex + 1) % fonts.length;
      applyCurrentFont();
    }
    
    function cycleFontBackward() {
      currentFontIndex = (currentFontIndex - 1 + fonts.length) % fonts.length;
      applyCurrentFont();
    }
    
             function applyCurrentFont() {
      const selectedFont = fonts[currentFontIndex];
      console.log('Applying font:', selectedFont);
      
      // Update the CSS custom property
      document.documentElement.style.setProperty('--font-family', selectedFont.family);
      
      // Apply font family to all text elements
      const allTextElements = document.querySelectorAll('#unscramble, #prompt, #nav-msg, #nav-prev, #nav-next, #slide-counter');
      allTextElements.forEach(el => {
        if (el) {
          el.style.fontFamily = selectedFont.family;
        }
      });
      
      // Also apply to body to ensure all elements inherit the font
      document.body.style.fontFamily = selectedFont.family;
      
      console.log(`Font changed to: ${selectedFont.family}`);
    }

    window.addEventListener('keydown', (e) => {
      // Mute any keyboard sounds
      e.preventDefault();
      
      // Check if we're in timeline reveal mode first
      if (isInTimelineRevealMode && (e.code==='Space'||e.code==='ArrowRight')) {
        showNextTimelineSection();
        return;
      }
      
      // Check if we're in line reveal mode
      if (isInLineRevealMode && (e.code==='Space'||e.code==='ArrowRight')) {
        showNextLineManual();
        return;
      }
      
      if (e.code==='Space'||e.code==='ArrowRight'){ unlockAudioContext(); startPage(currentPage+1); }
      else if (e.code==='ArrowLeft'){ unlockAudioContext(); startPage(currentPage-1); }

      const k = e.key;
     if (k==='ArrowUp'){ 
 pageModes[currentPage]=getNextImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
       else if (k==='ArrowDown'){ 
 pageModes[currentPage]=getPreviousImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
      // Font cycling removed - using fixed font system
      else if (k==='l'||k==='L'){ 
pageModes[currentPage]=IMG_BELOW; 
markUserSetMode(currentPage); 
showImage(currentPage); 
      }
     else if (k==='s'||k==='S'){ 
pageModes[currentPage]=IMG_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='a'||k==='A'){ 
pageModes[currentPage]=IMG_SMALL_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='o'||k==='O'){ 
pageModes[currentPage]=IMG_OFF; 
markUserSetMode(currentPage); 
showImage(currentPage); 
resetTextContainer(); 
      }
      else if (k==='z'||k==='Z'){ toggleGreenOverlay('full'); }
      else if (k==='x'||k==='X'){ toggleGreenOverlay('half'); }
      else if (k==='c'||k==='C'){ toggleGreenOverlay('off'); }
      else if (k==='m'||k==='M'){ toggleAudio(); }
      else if (k==='t'||k==='T'){ testBeep(); }
      else if (k==='q'||k==='Q'){ prevSoundVariation(); }
      else if (k==='w'||k==='W'){ nextSoundVariation(); }
      else if (k==='f'||k==='F'){ toggleFullscreen(); }
      else if (k==='a'||k==='A'){ 
        console.log('🧪 A key pressed - testing audio...');
        testAudio();
      }
      // Removed unused video keyboard shortcuts to optimize file size
    });
    
    // Fullscreen functionality
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
document.documentElement.requestFullscreen().catch(err => {
  console.log(`Error attempting to enable fullscreen: ${err.message}`);
});
      } else {
document.exitFullscreen();
      }
    }

    /* ================== COLOR/GLOW ================== */
    (function(){
      const navPrev = document.getElementById('nav-prev');
      const navNext = document.getElementById('nav-next');
      const terminals = [document.getElementById('unscramble'), document.getElementById('prompt'), document.getElementById('nav-msg'), navPrev, navNext, document.getElementById('slide-counter')];
      let colorIndex=2; // Default to soft green (option 3)
      const colors=['#CCCCCC','#00FF00','#66FF66'];
      function apply(){
terminals.forEach(el=>{ if(!el) return;
  el.style.color = colors[colorIndex];
  el.style.textShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`; // Glow always on
});

// Update cursor color to match
const customCursor = document.getElementById('custom-cursor');
if (customCursor) {
  customCursor.style.background = colors[colorIndex];
  customCursor.style.boxShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`;
}
      }
      document.addEventListener('keydown', (e)=>{
if (e.key==='1'||e.key==='2'||e.key==='3'){ colorIndex=parseInt(e.key,10)-1; apply(); }
      });
      apply();
    })();

    /* ================== INIT ================== */
    window.onload = () => {
      // Start presentation immediately when DOM is loaded
      startPage(0);
      
      // Initialize audio context for mobile on first load
      if (window.innerWidth <= 768) {
        console.log('📱 Mobile device detected - initializing audio...');
        initAudioContext();
        audioEnabled = true;
      }
      
      // Mute all audio by default
      document.addEventListener('keydown', (e) => {
        e.preventDefault();
      });
      
      // Mute all audio elements by default
      document.querySelectorAll('audio, video').forEach(media => {
        media.muted = true;
        media.volume = 0;
      });
      
      // Video will only show on page 15 via the page navigation logic
      // Hide any images that fail to load
      document.querySelectorAll('#page img').forEach(img => {
img.addEventListener('error', () => {
  img.style.display = 'none';
});
      });
      
      // Custom cursor functionality
      const customCursor = document.getElementById('custom-cursor');
      
      document.addEventListener('mousemove', (e) => {
customCursor.style.display = 'block';
customCursor.style.left = e.clientX - 10 + 'px';
customCursor.style.top = e.clientY - 10 + 'px';
      });
      
      document.addEventListener('mouseleave', () => {
customCursor.style.display = 'none';
      });
      
      // Apply the default font (IBM3270) on page load
      applyCurrentFont();
    };
    
    // Global green overlay toggle function
    let currentOverlayMode = 'full'; // Track current overlay mode - default to full green
    
    function toggleGreenOverlay(mode) {
      currentOverlayMode = mode; // Store the current mode
      const images = document.querySelectorAll('#page img');
      images.forEach(img => {
applyOverlayToImage(img, mode);
      });
      
    }
    
       // Apply overlay to a specific image
      function applyOverlayToImage(img, mode) {
// Check if this is photo23 (which should stay dimmed) or page 10 images (which should be darker)
const isDimmedPhoto = img.id === 'img-23';
const isDarkerPhoto = img.id.startsWith('img-10');
const baseBrightness = isDarkerPhoto ? 0.35 : (isDimmedPhoto ? 0.32 : 0.64);

if (mode === 'full') {
  img.style.filter = `grayscale(1) brightness(${baseBrightness}) contrast(1.2) sepia(1) hue-rotate(60deg) saturate(2)`;
} else if (mode === 'half') {
  img.style.filter = `brightness(${baseBrightness}) grayscale(1)`;
} else if (mode === 'off') {
  img.style.filter = `brightness(${baseBrightness})`;
}
      }
    
     
     
  </script>
  
  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/OutputPass.js"></script>
  
  <!-- Shaders for 3D Audio Visualizer -->
  <script id="vertexshader" type="vertex">
    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 permute(vec4 x) {
      return mod289(((x*34.0)+10.0)*x);
    }

    vec4 taylorInvSqrt(vec4 r) {
      return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec3 fade(vec3 t) {
      return t*t*t*(t*(t*6.0-15.0)+10.0);
    }

    float pnoise(vec3 P, vec3 rep) {
      vec3 Pi0 = mod(floor(P), rep);
      vec3 Pi1 = mod(floor(P) + vec3(1.0), rep);
      Pi0 = mod289(Pi0);
      Pi1 = mod289(Pi1);
      vec3 Pf0 = fract(P);
      vec3 Pf1 = Pf0 - vec3(1.0);
      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
      vec4 iy = vec4(Pi0.yy, Pi1.yy);
      vec4 iz0 = vec4(Pi0.z);
      vec4 iz1 = vec4(Pi1.z);

      vec4 ixy = permute(permute(ix) + iy);
      vec4 ixy0 = permute(ixy + iz0);
      vec4 ixy1 = permute(ixy + iz1);

      vec4 gx0 = ixy0 * (1.0 / 7.0);
      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
      gx0 = fract(gx0);
      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
      vec4 sz0 = step(gz0, vec4(0.0));
      gx0 -= sz0 * (step(0.0, gx0) - 0.5);
      gy0 -= sz0 * (step(0.0, gy0) - 0.5);

      vec4 gx1 = ixy1 * (1.0 / 7.0);
      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
      gx1 = fract(gx1);
      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
      vec4 sz1 = step(gz1, vec4(0.0));
      gx1 -= sz1 * (step(0.0, gx1) - 0.5);
      gy1 -= sz1 * (step(0.0, gy1) - 0.5);

      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
      g000 *= norm0.x;
      g010 *= norm0.y;
      g100 *= norm0.z;
      g110 *= norm0.w;
      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
      g001 *= norm1.x;
      g011 *= norm1.y;
      g101 *= norm1.z;
      g111 *= norm1.w;

      float n000 = dot(g000, Pf0);
      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
      float n111 = dot(g111, Pf1);

      vec3 fade_xyz = fade(Pf0);
      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
      return 2.2 * n_xyz;
    }

    uniform float u_time;
    uniform float u_frequency;
    uniform float u_red;
    uniform float u_green;
    uniform float u_blue;

    void main() {
      float noise = 3.0 * pnoise(position + u_time, vec3(10.0));
      float displacement = (u_frequency / 30.0) * (noise / 10.0);
      vec3 newPosition = position + normal * displacement;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
    }
  </script>

  <script id="fragmentshader" type="fragment">
    uniform float u_red;
    uniform float u_green;
    uniform float u_blue;
    
    void main() {
      gl_FragColor = vec4(vec3(u_red, u_green, u_blue), 1.0);
    }
  </script>
  
</body>
</html>
  
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Unscramble + Images</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Font Definitions */
    @font-face {
      font-family: 'IBM3270';
      src: url('fonts/3270-Regular.woff2') format('woff2'),
           url('fonts/3270-Regular.ttf') format('truetype'),
           url('fonts/3270-Regular.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'PixelCarnageMono';
      src: url('fonts/PixelCarnageMono.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'Crisp';
      src: url('fonts/Crisp.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggyCleanCE';
      src: url('fonts/ProggyCleanCE.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    @font-face {
      font-family: 'ProggySquare';
      src: url('fonts/ProggySquare.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
    
    :root { 
      --fg:#D4D4D4; 
      --bg:#000; 
      --accent:#00FF00; 
      --soft:#66FF66;
      --font-family: monospace;
    }
    html, body { height:100%; }
    
    /* FORCE NO SCROLLING */
    html {
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    
    body {
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background:var(--bg); 
      color:var(--fg); 
      font-family:var(--font-family);
      padding:5vw; 
      padding-left: 20vw;
      max-width:80vw; 
      margin: 2vh auto; 
      line-height:1.6; 
      user-select:none;
      font-size: 1rem;
      min-height: 100vh;
      box-sizing: border-box;
    }
    
    /* CRT scanline effect */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
transparent 0px,
transparent 2px,
rgba(0, 255, 0, 0.03) 2px,
rgba(0, 255, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 99998;
    }
    
    /* Black scanlines on top */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: repeating-linear-gradient(
0deg,
rgba(0, 0, 0, 0.20) 0px,
rgba(0, 0, 0, 0.20) 2px,
transparent 2px,
transparent 4px
      );
      pointer-events: none;
      z-index: 99999;
    }
    
    @media (max-width: 768px) {
      body {
padding: 4vw;
margin: 3vh auto;
font-size: 1rem;
      }
      #page {
padding: 2vw;
      }
            #unscramble {
        font-size: 1.0rem;
        line-height: 1.3;
      }
      #nav {
font-size: 1.5rem;
margin: 2vh 0 1vh;
      }
      #nav-msg {
font-size: 0.9rem;
      }
      #hud {
font-size: 0.8rem;
flex-direction: column;
gap: 0.5rem;
      }
      #page-counter {
bottom: 1vh;
right: 2vw;
      }
    }
    
    @media screen and (min-resolution: 1dppx) {
            body {
        font-size: 1.0rem;
      }
    }
    #page {
      position:relative; 
      height: 60vh;
      min-height: 20em; 
      padding:2rem; 
      border-radius:10px;
      background-size:cover; 
      background-position:center; 
      background-repeat:no-repeat;
      overflow: visible; /* Allow text to be visible */
    }
    
 /* Simple image display */
     #page img {
       display: none;
       filter: brightness(0.7) sepia(1) hue-rotate(60deg) saturate(1.5); /* Default: full green overlay - original brightness */
       /* Ensure all image formats including GIFs display properly */
       image-rendering: auto;
     }
     
   /* Special rule: dim only photo7 */
      #page img[id="img-7"] {
filter: brightness(0.3) sepia(1) hue-rotate(60deg) saturate(1.5); /* Photo7 dimmed as requested */
      }
      
      /* Special rule: dim only photo23 */
      #page img[id="img-23"] {
filter: brightness(0.3) sepia(1) hue-rotate(60deg) saturate(1.5); /* Photo23 dimmed as requested */
      }
    
    #page img.show-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -1;
      display: block;
    }
    
 #page img.show-below {
       display: block;
       margin-top: 1rem;
       max-height: 40%;
       max-width: 100%;
       object-fit: contain;
       position: relative;
       top: -12rem;
       z-index: -1;
     }
    
     #page img.show-side {
display: block;
position: absolute;
right: 0;
top: 0;
width: 50%;
height: 100%;
object-fit: cover;
z-index: 1;
      }
      
     #page img.show-small-side {
 display: block;
 position: absolute;
 right: 0;
 top: 0;
 width: 25%;
 height: 60%;
 object-fit: cover;
 z-index: 1;
       }
    
    /* Text container width is now controlled by JavaScript */
    
    /* Hide the default cursor */
    body {
      cursor: none;
    }
    
    /* Custom cursor element */
    #custom-cursor {
      position: fixed;
      width: 10px;
      height: 10px;
      background: var(--accent);
      border-radius: 50%;
      pointer-events: none;
      z-index: 10000;
      mix-blend-mode: difference;
      display: none;
    }
    
 #text-wrap { 
       min-width:0; 
       margin-top: -1.4rem; 
       width: 100%;
       height: calc(100% - 2rem); /* Ensure text doesn't overlap with navbar */
       box-sizing: border-box;
       overflow: hidden;
     }
                    #unscramble { 
      white-space: pre-wrap; 
      font-size: 1.1rem;
      line-height: 1.5;
      word-wrap: break-word;
      overflow-wrap: break-word;
      height: 100%;
      overflow: hidden;
      width: 100%;
      box-sizing: border-box;
      max-width: 100%;
      /* Preserve original formatting - no text wrapping modifications */
      text-indent: 0;
      word-break: normal;
      hyphens: none;
    }
     
     /* Handle indented line wrapping - preserve indentation for continuation lines */
     #unscramble .indented-line {
       display: block;
       text-indent: 2em; /* Standard indentation */
     }
     
     #unscramble .continuation {
       display: block;
       text-indent: 2em; /* Same indentation as parent */
     }
    #prompt { 
      margin-top:1rem; 
      visibility:hidden; 
      white-space:pre-wrap; 
      line-height:1.3; 
      font-size: 0.9rem;
    }

    #nav { 
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 3vh 0 1vh; 
      font-size: 1.5rem;
      min-height: 5vh;
      position: relative;
      gap: 4vw;
    }
    #nav span { cursor:pointer; user-select:none; padding:0 1em; }
          #nav-msg { 
      flex-grow:1; 
      text-align:center; 
      font-size:0.9rem;
      min-height: 1.5rem;
      visibility: hidden;
    }
    #hud { 
      margin-top:1vh; 
      font-size:0.8rem;
      display:flex; 
      align-items:center; 
      gap:1rem; 
      opacity:.9; 
    }
    #hud .badge { 
      display:inline-block; 
      border:1px solid var(--accent); 
      padding:.2rem .5rem; 
      border-radius:999px; 
      font-weight:bold; 
      letter-spacing:.03em; 
      color: var(--accent);
      text-shadow: 0 0 2px var(--accent), 0 0 12px var(--accent);
    }
    #hud .controls { 
      display: none;
    }
    
    #page-counter {
      position: fixed;
      bottom: 2vh;
      right: 3vw;
      font-size: 0.7rem;
      opacity: 0.6;
      color: var(--accent);
      text-shadow: 0 0 2px var(--accent), 0 0 8px var(--accent);
      font-family: var(--font-family);
      pointer-events: none;
      z-index: 1000;
    }
    
   /* Side mode: text on left, image on right */
      #text-wrap.side-mode {
width: 50% !important;
max-width: 50% !important;
position: relative !important;
z-index: 2 !important;
      }
      
     /* Small side mode: text on left, smaller image on right */
       #text-wrap.small-side-mode {
 width: 75% !important;
 max-width: 75% !important;
 position: relative !important;
 z-index: 2 !important;
       }
    
  #text-wrap.side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
    }
    
    #text-wrap.small-side-mode #unscramble {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      white-space: pre-wrap !important;
      word-wrap: normal !important;
      overflow-wrap: normal !important;
      hyphens: none !important;
      text-indent: 0 !important;
      font-size: 1.0rem !important;
      line-height: 1.3 !important;
    }
    
    /* Smaller font size for title slide (page 1) to fix mobile line break */
    #page[data-page="1"] #unscramble {
      font-size: 0.8rem !important;
      line-height: 1.4 !important;
    }
     
     /* Special rule: make slide 11 text slightly smaller to prevent navbar overlap */
     #page[data-page="11"] #unscramble {
       font-size: 1.0rem !important;
       line-height: 1.3 !important;
     }
  </style>
</head>
<body>
  <div id="page">
    <div id="text-wrap">
      <div id="unscramble"></div>
      <div id="prompt"></div>
    </div>
    
    <!-- Images will be added here dynamically -->
  </div>

  <div id="nav">
    <span id="nav-prev">&lt;</span>
    <span id="nav-msg"></span>
    <span id="nav-next">&gt;</span>
  </div>

  <div id="hud">
 <span class="controls">[1/2/3] color • [↑/↓] image mode • [N/B] font • [L] below • [S] side • [A] small side • [O] off • [Z/X/C] overlay • [M] sound • [T] test • [Q/W] sound type</span>
  </div>

  <div id="page-counter">Page <span id="current-page">1</span></div>
  
  <!-- Custom cursor -->
  <div id="custom-cursor"></div>

  <script>
    /* ================== AUDIO SYSTEM WITH DEBUG ================== */
    let audioContext = null;
    let audioEnabled = true;
    let debugMode = true;
    let currentSoundVariation = 0; // 0-4 for 5 different variations
    
    // Enhanced audio context initialization with debugging
    function initAudioContext() {
      if (debugMode) console.log('🔊 Initializing audio context...');
      
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          console.log('✅ Audio context created successfully:', audioContext.state);
          
          // Resume audio context if suspended (required by Chrome)
          if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('✅ Audio context resumed from suspended state');
            }).catch(err => {
              console.error('❌ Failed to resume audio context:', err);
            });
          }
        } catch (e) {
          console.error('❌ Audio context creation failed:', e);
          audioEnabled = false;
          showAudioError('Audio not supported in this browser');
        }
      }
      return audioContext !== null;
    }
    
    // Show audio error in the UI
    function showAudioError(message) {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = `AUDIO ERROR: ${message}`;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#FF6666';
        
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 3000);
      }
    }
    
    // Enhanced beep function with multiple fallback methods
    function playBeep(frequency = 800, duration = 0.08, volume = 0.5) {
      if (!audioEnabled) {
        if (debugMode) console.log('🔇 Audio disabled, skipping beep');
        return;
      }
      
      if (!audioContext && !initAudioContext()) {
        if (debugMode) console.error('❌ No audio context available');
        return;
      }
      
      try {
        if (debugMode) console.log(`🎵 Playing beep: ${frequency}Hz, ${duration}s, vol:${volume}`);
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        // Use sine wave for better compatibility
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        
        // Envelope for smooth attack/decay
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
        
        if (debugMode) console.log('✅ Beep scheduled successfully');
        
      } catch (e) {
        console.error('❌ Beep playback failed:', e);
        showAudioError('Playback failed');
      }
    }
    
    // Test beep with camera shutter burst
    function testBeep() {
      console.log('🧪 Testing camera shutter audio...');
      
      // Show visual feedback
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        navMsg.textContent = 'TESTING SHUTTER BEEPS...';
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#FFFF00';
      }
      
      // Initialize audio if needed
      if (!initAudioContext()) {
        console.error('❌ Test failed: Could not initialize audio');
        return;
      }
      
      // Play rapid shutter-like test sequence
      const frequency = 1200;
      const volume = 0.4;
      const beepDuration = 0.025;
      const rapidBeeps = 8; // More beeps for testing
      
      for (let i = 0; i < rapidBeeps; i++) {
        setTimeout(() => {
          playBeep(frequency, beepDuration, volume);
        }, i * 12); // Very rapid - 12ms between beeps
      }
      
      // Restore UI after test
      setTimeout(() => {
        if (navMsg) {
          navMsg.textContent = 'PRESS SPACEBAR TO CONTINUE';
          navMsg.style.color = '';
        }
      }, 1000);
    }
    
    // 5 Different shutter sound variations
    const soundVariations = [
      {
        name: "Classic Shutter",
        frequency: 1200,
        beepsPerChunk: 4,
        timeBetweenBeeps: 10,
        beepDuration: 0.025,
        volume: 0.3
      },
      {
        name: "Deep Mechanical",
        frequency: 800,
        beepsPerChunk: 3,
        timeBetweenBeeps: 15,
        beepDuration: 0.035,
        volume: 0.35
      },
      {
        name: "High Frequency Burst",
        frequency: 1600,
        beepsPerChunk: 6,
        timeBetweenBeeps: 8,
        beepDuration: 0.020,
        volume: 0.25
      },
      {
        name: "Stutter Pattern",
        frequency: 1000,
        beepsPerChunk: 5,
        timeBetweenBeeps: [5, 5, 20, 5, 5], // Variable timing for stutter effect
        beepDuration: 0.030,
        volume: 0.32
      },
      {
        name: "Dual Tone",
        frequency: [1400, 1100], // Two alternating frequencies
        beepsPerChunk: 4,
        timeBetweenBeeps: 12,
        beepDuration: 0.025,
        volume: 0.28
      }
    ];
    
    // Rapid camera shutter-like beeps with variations
    function playDecodingBeeps(chunkIndex, totalChunks) {
      if (!audioEnabled) return;
      
      const variation = soundVariations[currentSoundVariation];
      
      for (let i = 0; i < variation.beepsPerChunk; i++) {
        setTimeout(() => {
          let freq = variation.frequency;
          let vol = variation.volume;
          
          // Handle special variations
          if (currentSoundVariation === 3) { // Stutter Pattern
            // Use variable timing array
            const delay = variation.timeBetweenBeeps.slice(0, i).reduce((a, b) => a + b, 0);
          } else if (currentSoundVariation === 4) { // Dual Tone
            // Alternate between two frequencies
            freq = variation.frequency[i % 2];
          }
          
          playBeep(freq, variation.beepDuration, vol);
        }, getBeepDelay(variation, i));
      }
    }
    
    // Calculate delay for each beep based on variation
    function getBeepDelay(variation, beepIndex) {
      if (currentSoundVariation === 3 && Array.isArray(variation.timeBetweenBeeps)) {
        // Stutter pattern with variable timing
        return variation.timeBetweenBeeps.slice(0, beepIndex).reduce((a, b) => a + b, 0);
      } else {
        // Regular timing
        const timing = Array.isArray(variation.timeBetweenBeeps) ? 
                      variation.timeBetweenBeeps[0] : variation.timeBetweenBeeps;
        return beepIndex * timing;
      }
    }
    
    // Cycle to next sound variation
    function nextSoundVariation() {
      currentSoundVariation = (currentSoundVariation + 1) % soundVariations.length;
      showSoundVariation();
      testCurrentVariation();
    }
    
    // Cycle to previous sound variation
    function prevSoundVariation() {
      currentSoundVariation = (currentSoundVariation - 1 + soundVariations.length) % soundVariations.length;
      showSoundVariation();
      testCurrentVariation();
    }
    
    // Show current sound variation in UI
    function showSoundVariation() {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const variation = soundVariations[currentSoundVariation];
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = `SOUND: ${variation.name.toUpperCase()}`;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#00FFFF';
        
        console.log(`🎵 Switched to: ${variation.name}`);
        
        // Restore UI after showing variation
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 1500);
      }
    }
    
    // Test current sound variation
    function testCurrentVariation() {
      if (!audioEnabled) return;
      
      const variation = soundVariations[currentSoundVariation];
      
      // Play a sample of the current variation
      setTimeout(() => {
        for (let i = 0; i < variation.beepsPerChunk; i++) {
          setTimeout(() => {
            let freq = variation.frequency;
            
            // Handle special variations for testing
            if (currentSoundVariation === 4) { // Dual Tone
              freq = variation.frequency[i % 2];
            }
            
            playBeep(freq, variation.beepDuration, variation.volume);
          }, getBeepDelay(variation, i));
        }
      }, 300);
    }

    // Toggle audio with enhanced feedback
    function toggleAudio() {
      audioEnabled = !audioEnabled;
      console.log(`🔊 Audio ${audioEnabled ? 'ENABLED' : 'DISABLED'}`);
      
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = audioEnabled ? 'SOUND ON' : 'SOUND OFF';
        navMsg.style.visibility = 'visible';
        navMsg.style.color = audioEnabled ? '#00FF00' : '#FF6666';
        
        // Play confirmation beep if enabling
        if (audioEnabled) {
          setTimeout(() => {
            testBeep();
          }, 200);
        }
        
        // Restore UI
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 2000);
      }
    }

    
    
    // Show temporary message
    function showTemporaryMessage(message) {
      const navMsg = document.getElementById('nav-msg');
      if (navMsg) {
        const originalText = navMsg.textContent;
        const originalVisibility = navMsg.style.visibility;
        
        navMsg.textContent = message;
        navMsg.style.visibility = 'visible';
        navMsg.style.color = '#00FF00';
        
        setTimeout(() => {
          navMsg.textContent = originalText;
          navMsg.style.visibility = originalVisibility;
          navMsg.style.color = '';
        }, 2000);
      }
    }

    /* ================== SIMPLE AUDIO + VISUAL WAVEFORM ================== */
    function startAudio() {
      console.log('🎵 Starting audio with visual waveform...');
      
      // Hide text first
      const textWrap = document.getElementById('text-wrap');
      if (textWrap) textWrap.style.display = 'none';
      
      // Create simple audio element (NO Web Audio API)
      const audio = document.createElement('audio');
      audio.src = 'AUDIO/Varoufakis - deal 6 Billion Dollars.mp3';
      audio.autoplay = true;
      audio.volume = 0.8;
      audio.style.display = 'none';
      document.body.appendChild(audio);
      
      // Create visual waveform (completely separate from audio)
      createVisualWaveform();
      
      // Play audio
      audio.play().then(() => {
        console.log('🎵 Audio playing successfully');
        startVisualWaveform();
      }).catch(e => {
        console.log('🎵 Auto-play failed, trying with user gesture');
        setTimeout(() => {
          audio.play().then(() => {
            startVisualWaveform();
          }).catch(err => {
            console.log('🎵 Audio play failed:', err);
          });
        }, 100);
      });
    }
    
    function createVisualWaveform() {
      const canvas = document.createElement('canvas');
      canvas.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90vw;
        height: 25vh;
        background: transparent;
        z-index: 10;
      `;
      
      canvas.width = window.innerWidth * 0.9;
      canvas.height = window.innerHeight * 0.25;
      
      const ctx = canvas.getContext('2d');
      document.getElementById('page').appendChild(canvas);
      
      // Store for animation
      window.visualCanvas = canvas;
      window.visualCtx = ctx;
    }
    
    function startVisualWaveform() {
      if (!window.visualCanvas || !window.visualCtx) return;
      
      const canvas = window.visualCanvas;
      const ctx = window.visualCtx;
      
      // Simulate realistic speech waveform patterns
      function drawSpeechWaveform() {
        const width = canvas.width;
        const height = canvas.height;
        const time = Date.now() * 0.001;
        
        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = '#00FF00';
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        for (let x = 0; x < width; x += 2) {
          const progress = x / width;
          
          // Simulate speech patterns with multiple frequency components
          const speech = 
            Math.sin(progress * 30 + time * 2) * 0.4 +           // Main speech frequency
            Math.sin(progress * 60 + time * 3.2) * 0.25 +        // Higher harmonics
            Math.sin(progress * 15 + time * 1.1) * 0.2 +         // Lower formants
            (Math.random() - 0.5) * 0.1;                         // Noise/texture
          
          // Simulate speech envelope (louder and quieter periods)
          const envelope = 
            0.7 + 0.3 * Math.sin(time * 0.8) +                   // Slow volume changes
            0.2 * Math.sin(time * 2.3) +                         // Faster variations
            0.1 * Math.sin(time * 4.7);                          // Quick fluctuations
          
          const amplitude = Math.max(0.1, envelope) * 60;
          const y = height / 2 + speech * amplitude;
          
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        requestAnimationFrame(drawSpeechWaveform);
      }
      
      drawSpeechWaveform();
      console.log('🎵 Visual waveform started');
    }
    

    /* ================== CONTENT ================== */
    const fullTextRaw = `THE SIX BILLION DOLLAR
MAN


PRESS [F] FOR FULLSCREEN







A FILM BY EUGENE JARECKI





OUR WORLD IS AT WAR, AS IT ALWAYS HAS BEEN

BUT PERHAPS THE MOST INFLUENTIAL WAR BEING WAGED
IS THE WAR OF INFORMATION






COGNITIVE WARFARE HAS BECOME THE WAY FOR FASCISTS TO CONSOLIDATE THEIR POWER THROUGH

	>	OBSCURITY
	>	CENSORSHIP
	>	DISINFORMATION
	>	SURVEILLANCE






YOU KNOW THIS, HAVING PLAYED A HUGE PART ON BEHALF OF THE RESISTANCE TO SURVEILLANCE CAPITALISM THROUGH YOUR INVOLVEMENT WITH THE CYPHERPUNK MOVEMENT.

    >   NOSTR
    >   BITCOIN
    >   BLUESKY
    >   WEB3



    
OUR FILM FOCUSES ON ANOTHER BIG PLAYER IN THE WAR, A MAN WHO SHARES YOUR ROOTS IN THE CYPHERPUNK MOVEMENT,
		
	> JULIAN ASSANGE, THE FOUNDER OF WIKILEAKS






ONCE LAUDED AS A FOLK HERO FOR EXPOSING WAR CRIMES AND CORRUPTION

HIS REPUTATION WAS SUCCESSFULLY ASSASINATED BY U.S.A. AND U.K. MEDIA CONTROL







IMPRISONED, SPIED ON, TORTURED, ASSANGE WAS USED TO SET AN EXAMPLE TO THOSE WHO MIGHT DARE TO CHALLENGE THE LIES AND SECRECY OF THE EMPIRE





FEATURING EXCLUSIVE ACCESS TO FOOTAGE DIRECTLY FROM THE WIKILEAKS TEAM 

AS WELL AS INTERVIEWS WITH EXPERTS, WIKILEAKS STAFF, LOVED ONES,

AND A WHISTLEBLOWER FROM THE ORGANISATION THE CIA HIRED TO SPY ON THEM





WE TELL THE TRUE STORY OF HOW WIKILEAKS USED INFORMATION 

	>	TO BRING DOWN CORRUPT REGIMES

	>	TO EXPOSE GOVERNMENT CORRUPTION AND DEMOCRATIC INTERFERENCE

	>	TO HELP END WARS







AND TO SHOW HOW THE PEOPLE FAUGHT FOR HIS RELEASE, AGAINST THE MOST POWERFUL GOVERNMENTS OF THE WORLD,

		AND WON.






WHEN MAINSTREAM FINANCIAL INSTITUTIONS CAVED TO GOVERNMENT PRESSURES DURING THE BANKING BLOCKADE ON WIKILEAKS

THE ORGANISATION SURVIVED THROUGH BITCOIN DONATIONS






WHEN MAINSTREAM MEDIA BROADCASTED LIES TO SLANDER HIM,

THE PEOPLE COULD FIND THE TRUTH ONLINE ON DECENTRALISED MEDIA PLATFORMS





JULIAN ASSANGE WAS MEANT TO SHOW JOURNALISTS THAT TO OPPOSE THEM MEANS DEATH AND DEFEAT

WE WANT THE PEOPLE TO KNOW THAT THIS IS A LIE

THOSE IN POWER ARE NOT UNTOUCHABLE

THAT THERE IS A WAR WE'RE ALL A PART OF AND WHICH ALL OF US HAVE A DUTY TO FIGHT




WE HAVE ALREADY MET RESISTANCE IN TRADITIONAL MEDIA CHANNELS

EVEN AFTER OUR PREMIERE AT CANNES FILM FESTIVAL AND SEVERAL AWARDS EARNED, THE MAINSTREAM MEDIA IS RELUCTANT TO STAND AGAINST THE GOVERNMENT 

CORPORATE PLATFORMS BENEFIT FROM A DISTRACTED AUDIENCE AND A DISCREDITED ASSANGE

THE WORLD BENEFITS FROM THE TRUTH




					WHAT WE'RE ASKING


> INITIAL CRYPTO CONTRIBUTION TO FUND 
		
	>	DISTRIBUTION, 
	>	PROMOTION,
	>	AND AN IMPACT CAMPAIGN

> PUBLIC ENDORSEMENT (IF DESIRED) TO GALVANISE THE BROADER CRYPTO SPHERE

> STRATEGIC GUIDANCE OR CONNECTION TO BITCOIN-ALIGNED DISTRIBUTION TOOLS
		




					USE OF FUNDS


> ACADEMY SCREENINGS AND CRYPTO-NATIVE DISTRIBUTION 
        (NFT ACCESS PASSES, DECENTRALISED STREAMING)

> LEGAL AND SECURITY SUPPORT FOR CONTRIBUTORS IN HIGH-RISK ZONES

> AGGRESSIVE PROMOTIONAL PUSH NOW THAT ASSANGE IS FREE AND PUBLIC ATTENTION IS RESURGENT

> TRANSPARENCY GUARANTEED: 
 	FUNDS HELD IN MULTI-SIG WALLET WITH REAL-TIME PUBLIC LEDGER





WE'RE UP AGAINST ENTRENCHED NARRATIVES AND OPPOSITION TO THE TRUTH

YOU CAN HELP US MAKE A DIFFERENCE, BYPASSING ATTEMPTS AT CENSORSHIP TO GET THIS FILM IN FRONT OF AN AUDIENCE







LET'S FINISH WHAT WE STARTED.

CONTACT:
[PRODUCERS' NAMES]
[SECURE EMAIL]
[WALLET ADDRESS (BTC/ETH)]





`;

    /* ================== PREP ================== */
    const fullText = fullTextRaw.toUpperCase();
    const pages = fullText.split(/\n{4,}/);
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,\'"?!-—:;\n';

 // Image modes
     const IMG_OFF = 0;
     const IMG_BG = 1;
     const IMG_BELOW = 2;
     const IMG_SIDE = 3;
     const IMG_SMALL_SIDE = 4;
    
    // Helper functions for cycling through image modes
    function getNextImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex + 1) % modes.length];
    }
    
    function getPreviousImageMode(currentMode) {
      const modes = [IMG_OFF, IMG_BG, IMG_BELOW, IMG_SIDE, IMG_SMALL_SIDE];
      const currentIndex = modes.indexOf(currentMode);
      return modes[(currentIndex - 1 + modes.length) % modes.length];
    }
    
    function markUserSetMode(pageIndex) {
      const pageNumber = pageIndex + 1;
      const imgEl = document.getElementById(`img-${pageNumber}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
      // Save to localStorage for persistence across refreshes
      savePageModeToStorage(pageIndex, pageModes[pageIndex]);
    }
    
    function savePageModeToStorage(pageIndex, mode) {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
storedModes[pageIndex] = mode;
localStorage.setItem('pitchDeckImageModes', JSON.stringify(storedModes));
      } catch (e) {
console.warn('Could not save image mode to localStorage:', e);
      }
    }
    
    function loadPageModesFromStorage() {
      try {
const storedModes = JSON.parse(localStorage.getItem('pitchDeckImageModes') || '{}');
Object.keys(storedModes).forEach(pageIndex => {
  const index = parseInt(pageIndex);
  if (index >= 0 && index < pageModes.length) {
    pageModes[index] = storedModes[pageIndex];
    // Mark as user-set so auto-detection doesn't override
    setTimeout(() => {
      const imgEl = document.getElementById(`img-${index + 1}`);
      if (imgEl) {
imgEl.setAttribute('data-user-set', 'true');
      }
    }, 100);
  }
});
      } catch (e) {
console.warn('Could not load image modes from localStorage:', e);
      }
    }
    
 const pageModes = new Array(pages.length).fill(IMG_OFF); // Default to no image mode for all pages
    
    // Load saved image modes from localStorage
    loadPageModesFromStorage();
    
    // All pages start with IMG_OFF and auto-detect images
     
     // Auto-detect pages with images and set them to side mode
     // This will be handled dynamically when images are found

    // DOM
    const pageEl = document.getElementById('page');
    const textWrap = document.getElementById('text-wrap');
    const el = document.getElementById('unscramble');
    const promptElem = document.getElementById('prompt');
    const navMsg = document.getElementById('nav-msg');
    const pageCounterEl = document.getElementById('current-page');

    let currentPage = 0;
    let isAnimating = false;
    let currentInterval = null;

    // Simple image function - check what photos actually exist
    function showImage(pageIndex) {
      // Hide all existing images first
      document.querySelectorAll('#page img').forEach(img => {
img.className = '';
      });
      
      const pageNumber = pageIndex + 1;
      let imgEl = document.getElementById(`img-${pageNumber}`);
      
      // If no image exists for this page yet, try to create one
      if (!imgEl) {
imgEl = createImageForPage(pageNumber);
      }
      
     // Show image if it exists - auto-set mode if needed
       if (imgEl) {
 // Only auto-set to SIDE mode if this is the first time and user hasn't manually set a mode
 if (pageModes[pageIndex] === IMG_OFF && !imgEl.hasAttribute('data-user-set')) {
   pageModes[pageIndex] = IMG_SIDE;
 }
 
 const mode = pageModes[pageIndex];
 if (mode === IMG_BG) imgEl.className = 'show-bg';
 else if (mode === IMG_BELOW) imgEl.className = 'show-below';
 else if (mode === IMG_SIDE) imgEl.className = 'show-side';
 else if (mode === IMG_SMALL_SIDE) imgEl.className = 'show-small-side';
       }
      
      // Only adjust text if there's actually an image showing
      if (imgEl && imgEl.complete && imgEl.naturalWidth > 0) {
adjustTextContainerWidth(pageModes[pageIndex]);
      } else {
adjustTextContainerWidth(IMG_OFF);
      }
    }
    
    // Create image for a page number - tries multiple formats
    function createImageForPage(pageNumber) {
      const img = document.createElement('img');
      img.id = `img-${pageNumber}`;
      img.alt = `Page ${pageNumber} Image`;
      
      // Start invisible - only show when successfully loaded
      img.style.opacity = '0';
      img.style.transition = 'opacity 0.2s ease-in-out';
      
      // Add to page first (invisible)
      document.getElementById('page').appendChild(img);
      
      // Try multiple formats in order
      tryImageFormats(img, pageNumber, 0);
      
      // Only show image when it loads successfully
      img.addEventListener('load', () => {
console.log(`Image loaded successfully for page ${pageNumber}`);
img.style.opacity = '1';

// Update page mode and layout if this is the current page
const pageIndex = pageNumber - 1;
if (pageIndex === currentPage) {
  // Only auto-set to SIDE mode on first load, don't override user choices
  if (pageModes[pageIndex] === IMG_OFF && !img.hasAttribute('data-user-set')) {
    pageModes[pageIndex] = IMG_SIDE;
  }
  adjustTextContainerWidth(pageModes[pageIndex]);
}

// Apply current overlay mode to new image
applyOverlayToImage(img, currentOverlayMode);
      });
      
      // Handle image loading errors gracefully
      img.addEventListener('error', () => {
console.log(`Failed to load image for page ${pageNumber}`);
img.style.display = 'none';
// Don't remove the image element - just hide it
      });
      
      return img;
    }
    
    // Adjust text container when side image is active
    function adjustTextForSideImage() {
      adjustTextContainerWidth(IMG_SIDE);
    }
    
    // Reset text container when image is turned off
    function resetTextContainer() {
      adjustTextContainerWidth(IMG_OFF);
    }
    
    // Adjust text container width based on image mode
    function adjustTextContainerWidth(imageMode) {
      const textWrap = document.getElementById('text-wrap');
      if (!textWrap) return;
      
   if (imageMode === IMG_SIDE) {
  // Side mode: text on left, image on right
  textWrap.style.setProperty('width', '50%', 'important');
  textWrap.style.setProperty('max-width', '50%', 'important');
  textWrap.style.setProperty('position', 'relative', 'important');
  textWrap.style.setProperty('z-index', '2', 'important');
  textWrap.classList.add('side-mode');
  textWrap.classList.remove('small-side-mode');
 } else if (imageMode === IMG_SMALL_SIDE) {
   // Small side mode: text on left, smaller image on right
   textWrap.style.setProperty('width', '75%', 'important');
   textWrap.style.setProperty('max-width', '75%', 'important');
   textWrap.style.setProperty('position', 'relative', 'important');
   textWrap.style.setProperty('z-index', '2', 'important');
   textWrap.classList.add('small-side-mode');
   textWrap.classList.remove('side-mode');
 } else {
  // All other modes: text uses full width
  textWrap.style.setProperty('width', '100%', 'important');
  textWrap.style.setProperty('max-width', '100%', 'important');
  textWrap.style.setProperty('position', '', 'important');
  textWrap.style.setProperty('z-index', '', 'important');
  textWrap.classList.remove('side-mode');
  textWrap.classList.remove('small-side-mode');
}
    }
    
    
    
    // Universal image support - tries all possible formats
    function tryImageFormats(img, pageNumber, formatIndex) {
      // Start with most compatible formats, then try everything else
      const formats = [
'jpg', 'jpeg', 'png', 'gif',  // Universal support
'webp', 'svg',// Modern browsers
'bmp', 'tiff', 'tif', // Desktop browsers
'avif', 'jfif', 'pjpeg'       // Newer formats
      ];
      
      if (formatIndex >= formats.length) {
// All formats failed, remove the image
console.log(`No image found for page ${pageNumber}`);
img.remove();
return;
      }
      
      const format = formats[formatIndex];
      const testSrc = `photos/photo${pageNumber}.${format}`;
      
      // Test if this format file exists by creating a test image
      const testImg = new Image();
      testImg.onload = function() {
// File exists and format is supported - use it!
console.log(`✅ Found working image: ${testSrc}`);
img.src = testSrc;
      };
      testImg.onerror = function() {
// This format/file doesn't work, try next
tryImageFormats(img, pageNumber, formatIndex + 1);
      };
      testImg.src = testSrc;
    }

      /* ================== TEXT TRUNCATION ================== */
      function truncateTextToFit(element, text) {
element.textContent = text;

// Get the text container to check available space
const textWrap = document.getElementById('text-wrap');
const availableHeight = textWrap ? textWrap.clientHeight : element.clientHeight;

// Only reduce font size if absolutely necessary, and be more conservative
if (element.scrollHeight > availableHeight) {
  let fontSize = parseFloat(getComputedStyle(element).fontSize);
  
  // Reduce font size more conservatively
  while (element.scrollHeight > availableHeight && fontSize > 1.2) {
    fontSize -= 0.05;
    element.style.fontSize = fontSize + 'rem';
  }
  
  // If still doesn't fit, add some padding to prevent navbar overlap
  if (element.scrollHeight > availableHeight) {
    element.style.paddingBottom = '2rem';
  }
}
      }

    /* ================== SCRAMBLE ================== */
    function scrambleFastChunks(element, text, onComplete) {
      if (currentInterval) {
clearInterval(currentInterval);
currentInterval = null;
      }
      
      let index = 0, chunkSize = 15, scrambled = text.split(''), len = text.length;
      for (let i=0;i<len;i++) scrambled[i] = /\s/.test(text[i]) ? text[i] : chars[Math.floor(Math.random()*chars.length)];
      isAnimating = true; promptElem.style.visibility='hidden'; navMsg.style.visibility='hidden';
      
      // Calculate total chunks for audio sync
      const totalChunks = Math.ceil(len / chunkSize);
      
      // Initialize audio context on first user interaction
      initAudioContext();

      currentInterval = setInterval(() => {
const display = scrambled.slice();
for (let i=0;i<index;i++){
  let s=i*chunkSize, e=Math.min(s+chunkSize,len);
  for (let j=s;j<e;j++) display[j]=text[j];
}
for (let k=index*chunkSize;k<len;k++) display[k] = /\s/.test(text[k]) ? text[k] : chars[Math.floor(Math.random()*chars.length)];
element.textContent = display.join('');

// Play synchronized beep for this chunk
playDecodingBeeps(index, totalChunks);

index++;
if ((index*chunkSize)>=len){
  clearInterval(currentInterval);
  currentInterval = null;
  truncateTextToFit(element, text);
  isAnimating=false;
  navMsg.textContent='PRESS SPACEBAR TO CONTINUE';
  navMsg.style.visibility='visible';
  onComplete && onComplete();
}
      },80);
    }

    /* ================== PAGE RENDER ================== */
 function startPage(pageIndex){
       if (pageIndex >= pages.length) pageIndex = 0;
       if (pageIndex < 0) pageIndex = pages.length - 1;
       currentPage = pageIndex;
       
       pageCounterEl.textContent = pageIndex + 1;
       navMsg.style.visibility = 'hidden';
       
       // Set data-page attribute for CSS targeting
       pageEl.setAttribute('data-page', pageIndex + 1);
      
      // Check if this is the audio page (last page)
      if (pageIndex === pages.length - 1) {
        // Show text first, then start audio after animation
        const textWrap = document.getElementById('text-wrap');
        if (textWrap) {
          textWrap.style.display = 'block';
        }

        el.textContent='';
        isAnimating = false;
        scrambleFastChunks(el, pages[pageIndex], () => {
          // After text animation, start audio
          setTimeout(() => {
            startAudio();
          }, 1000);
        });
      } else {
        // Show text for all other pages
        const textWrap = document.getElementById('text-wrap');
        if (textWrap) {
          textWrap.style.display = 'block';
        }

        el.textContent='';
        isAnimating = false;
        scrambleFastChunks(el, pages[pageIndex], () => {
          // Text displayed
        });
      }
      
      showImage(pageIndex);
    }

    /* ================== NAV ================== */
    let lastAdvance = 0;
    function throttle(){ const now=Date.now(); if (now-lastAdvance<300) return false; lastAdvance=now; return true; }
    function safeAdvance(){ if (!throttle()) return; startPage(currentPage+1); }
    function goBack(){ if (!throttle()) return; startPage(currentPage-1); }

    document.getElementById('nav-prev').addEventListener('pointerdown', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('pointerdown', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('touchstart', goBack, {passive:true});
    document.getElementById('nav-next').addEventListener('touchstart', safeAdvance, {passive:true});
    document.getElementById('nav-prev').addEventListener('click', goBack);
    document.getElementById('nav-next').addEventListener('click', safeAdvance);
 document.addEventListener('pointerdown', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       // Left half of screen goes back, right half goes forward
       if (e.clientX < window.innerWidth / 2) {
 goBack();
       } else {
 safeAdvance();
       }
     }, {passive:true});
     
     document.addEventListener('touchstart', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       // Left half of screen goes back, right half goes forward
       if (e.touches[0].clientX < window.innerWidth / 2) {
 goBack();
       } else {
 safeAdvance();
       }
     }, {passive:true});
 document.addEventListener('click', (e)=>{ 
       if (e.target.id==='nav-prev'||e.target.id==='nav-next') return; 
       
       // Left half of screen goes back, right half goes forward
       if (e.clientX < window.innerWidth / 2) {
 goBack();
       } else {
 safeAdvance();
       }
     });

    // Font cycling functionality - UPDATED WITH 6 FONTS - IBM3270 DEFAULT
    let currentFontIndex = 1; // Start with IBM3270 (index 1) as default
    let currentFontSize = 1.0; // Size multiplier (1.0 = 100% of base size)
         const fonts = [
       { family: 'monospace', size: '1.8rem' },
       { family: 'IBM3270', size: '1.8rem' },  // All fonts now use same base size
       { family: 'PixelCarnageMono', size: '1.8rem' },
       { family: 'Crisp', size: '1.8rem' },
       { family: 'ProggyCleanCE', size: '1.8rem' },
       { family: 'ProggySquare', size: '1.8rem' }
     ];
    
    function cycleFontForward() {
      currentFontIndex = (currentFontIndex + 1) % fonts.length;
      applyCurrentFont();
    }
    
    function cycleFontBackward() {
      currentFontIndex = (currentFontIndex - 1 + fonts.length) % fonts.length;
      applyCurrentFont();
    }
    
             function applyCurrentFont() {
      const selectedFont = fonts[currentFontIndex];
      console.log('Applying font:', selectedFont);
      
      // Update the CSS custom property
      document.documentElement.style.setProperty('--font-family', selectedFont.family);
      
      // Calculate the actual size with the current multiplier
      const baseSize = parseFloat(selectedFont.size);
      const actualSize = (baseSize * currentFontSize) + 'rem';
      
      // Apply the font family and size to main text elements (affected by size controls)
      const mainTextElements = document.querySelectorAll('#unscramble, #prompt');
      mainTextElements.forEach(el => {
        if (el) {
          el.style.fontFamily = selectedFont.family;
          // Check if we're on page 1 (title slide) and use smaller font size
          const currentPageNum = parseInt(pageEl.getAttribute('data-page') || '1');
          if (currentPageNum === 1) {
            el.style.fontSize = '0.8rem';
            el.style.lineHeight = '1.4';
          } else {
            el.style.fontSize = actualSize;
          }
        }
      });
      
      // Apply only font family to navbar and page counter (immune to size controls)
      const navElements = document.querySelectorAll('#nav-msg, #nav-prev, #nav-next, #page-counter');
      navElements.forEach(el => {
        if (el) {
          el.style.fontFamily = selectedFont.family;
          // Keep original sizes: nav-msg (0.9rem), nav-prev/next (1.5rem), page-counter (0.7rem)
        }
      });
      
      // Also apply to body to ensure all elements inherit the font
      document.body.style.fontFamily = selectedFont.family;
      
      console.log(`Font changed to: ${selectedFont.family} at size ${actualSize} (multiplier: ${currentFontSize})`);
    }

    window.addEventListener('keydown', (e) => {
      if (e.code==='Space'||e.code==='ArrowRight'){ e.preventDefault(); startPage(currentPage+1); }
      else if (e.code==='ArrowLeft'){ e.preventDefault(); startPage(currentPage-1); }

      const k = e.key;
     if (k==='ArrowUp'){ 
 pageModes[currentPage]=getNextImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
       else if (k==='ArrowDown'){ 
 pageModes[currentPage]=getPreviousImageMode(pageModes[currentPage]); 
 markUserSetMode(currentPage); 
 showImage(currentPage); 
       }
      else if (k==='n'||k==='N'){ 
        cycleFontForward();
      }
      else if (k==='b'||k==='B'){ 
        cycleFontBackward();
      }
      else if (k==='l'||k==='L'){ 
pageModes[currentPage]=IMG_BELOW; 
markUserSetMode(currentPage); 
showImage(currentPage); 
      }
     else if (k==='s'||k==='S'){ 
pageModes[currentPage]=IMG_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='a'||k==='A'){ 
pageModes[currentPage]=IMG_SMALL_SIDE; 
markUserSetMode(currentPage); 
showImage(currentPage); 
adjustTextForSideImage(); 
      }
       else if (k==='o'||k==='O'){ 
pageModes[currentPage]=IMG_OFF; 
markUserSetMode(currentPage); 
showImage(currentPage); 
resetTextContainer(); 
      }
      else if (k==='z'||k==='Z'){ toggleGreenOverlay('full'); }
      else if (k==='x'||k==='X'){ toggleGreenOverlay('half'); }
      else if (k==='c'||k==='C'){ toggleGreenOverlay('off'); }
      else if (k==='m'||k==='M'){ toggleAudio(); }
      else if (k==='t'||k==='T'){ testBeep(); }
      else if (k==='q'||k==='Q'){ prevSoundVariation(); }
      else if (k==='w'||k==='W'){ nextSoundVariation(); }
      else if (k==='f'||k==='F'){ toggleFullscreen(); }
    });
    
    // Fullscreen functionality
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
document.documentElement.requestFullscreen().catch(err => {
  console.log(`Error attempting to enable fullscreen: ${err.message}`);
});
      } else {
document.exitFullscreen();
      }
    }

    /* ================== COLOR/GLOW ================== */
    (function(){
      const navPrev = document.getElementById('nav-prev');
      const navNext = document.getElementById('nav-next');
      const terminals = [document.getElementById('unscramble'), document.getElementById('prompt'), document.getElementById('nav-msg'), navPrev, navNext, document.getElementById('page-counter')];
      let colorIndex=2; // Default to soft green (option 3)
      const colors=['#CCCCCC','#00FF00','#66FF66'];
      function apply(){
terminals.forEach(el=>{ if(!el) return;
  el.style.color = colors[colorIndex];
  el.style.textShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`; // Glow always on
});

// Update cursor color to match
const customCursor = document.getElementById('custom-cursor');
if (customCursor) {
  customCursor.style.background = colors[colorIndex];
  customCursor.style.boxShadow = `0 0 2px ${colors[colorIndex]}, 0 0 12px ${colors[colorIndex]}`;
}
      }
      document.addEventListener('keydown', (e)=>{
if (e.key==='1'||e.key==='2'||e.key==='3'){ colorIndex=parseInt(e.key,10)-1; apply(); }
      });
      apply();
    })();

    /* ================== INIT ================== */
    window.onload = () => {
      // Hide any images that fail to load
      document.querySelectorAll('#page img').forEach(img => {
img.addEventListener('error', () => {
  img.style.display = 'none';
});
      });
      
      // Custom cursor functionality
      const customCursor = document.getElementById('custom-cursor');
      
      document.addEventListener('mousemove', (e) => {
customCursor.style.display = 'block';
customCursor.style.left = e.clientX - 10 + 'px';
customCursor.style.top = e.clientY - 10 + 'px';
      });
      
      document.addEventListener('mouseleave', () => {
customCursor.style.display = 'none';
      });
      
      startPage(0);
      
      // Apply the default font (IBM3270) on page load
      applyCurrentFont();
    };
    
    // Global green overlay toggle function
    let currentOverlayMode = 'full'; // Track current overlay mode - default to full green
    
    function toggleGreenOverlay(mode) {
      currentOverlayMode = mode; // Store the current mode
      const images = document.querySelectorAll('#page img');
      images.forEach(img => {
applyOverlayToImage(img, mode);
      });
      
    }
    
       // Apply overlay to a specific image
      function applyOverlayToImage(img, mode) {
// Check if this is photo7 or photo23 (which should stay dimmed)
const isDimmedPhoto = img.id === 'img-7' || img.id === 'img-23';
const baseBrightness = isDimmedPhoto ? 0.3 : 0.7;

if (mode === 'full') {
  img.style.filter = `brightness(${baseBrightness}) sepia(1) hue-rotate(60deg) saturate(1.5)`;
} else if (mode === 'half') {
  img.style.filter = `brightness(${baseBrightness}) grayscale(1)`;
} else if (mode === 'off') {
  img.style.filter = `brightness(${baseBrightness})`;
}
      }
    
  </script>
</body>
</html>
